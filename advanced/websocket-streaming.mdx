---
title: WebSocket Streaming
description: Real-time communication with WebSocket connections for live updates and bidirectional messaging
---

# WebSocket Streaming

Erdo provides powerful WebSocket streaming capabilities for real-time communication between your agents and frontend applications. This enables live updates, progress tracking, and bidirectional messaging during agent execution.

## Overview

WebSocket streaming allows you to:

- Stream agent execution progress in real-time
- Send live updates during long-running operations
- Handle bidirectional communication
- Resume connections with message history
- Manage multiple client connections

<CardGroup cols={2}>
  <Card title="Real-time Updates" icon="bolt">
    Stream agent progress and results as they happen
  </Card>
  <Card title="Bidirectional Messaging" icon="arrows-left-right">
    Send and receive messages during execution
  </Card>
  <Card title="Connection Resumption" icon="arrow-rotate-left">
    Resume connections with message history
  </Card>
  <Card title="Multi-client Support" icon="users">
    Handle multiple client connections per resource
  </Card>
</CardGroup>

## Channel-based Architecture

WebSocket connections are organized around channels that represent different resource types:

<Tabs>
  <Tab title="Thread Channels">
    ```javascript
    // Subscribe to a specific thread
    const channel = {
      type: 'thread',
      resource_id: 'thread-uuid'
    };
    ```
  </Tab>
  <Tab title="Organization Channels">
    ```javascript
    // Subscribe to organization-wide events
    const channel = {
      type: 'organization',
      resource_id: 'org-uuid'
    };
    ```
  </Tab>
  <Tab title="User Channels">
    ```javascript
    // Subscribe to user-specific events
    const channel = {
      type: 'user',
      resource_id: 'user-uuid'
    };
    ```
  </Tab>
  <Tab title="Global Channels">
    ```javascript
    // Subscribe to system-wide events
    const channel = {
      type: 'global',
      resource_id: 'system'
    };
    ```
  </Tab>
</Tabs>

## Authentication & Connection

### Getting a WebSocket Ticket

Before connecting, you need to obtain an authentication ticket:

```javascript
const response = await fetch("/websocket/ticket", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    Authorization: "Bearer " + accessToken,
  },
  body: JSON.stringify({
    resource_type: "thread",
    resource_id: "thread-uuid",
  }),
});

const { ticket } = await response.json();
```

### Establishing Connection

Connect using the ticket with optional resumption:

```javascript
const wsUrl = `ws://localhost:4000/websocket/connect?ticket=${ticket}`;
const ws = new WebSocket(wsUrl);

// With connection resumption
const wsUrlWithResume = `${wsUrl}&resume_from_event_id=123&client_id=client-123`;
const wsResume = new WebSocket(wsUrlWithResume);
```

## Event Types & Messaging

### Flexible Event System

Erdo uses a flexible event system where any string can be an event type:

<AccordionGroup>
  <Accordion title="Thread Events">
    ```javascript // Common thread event types 'thread.message' // New message
    'thread.message.update' // Message updated 'thread.status.changed' // Thread
    status change 'thread.typing' // User typing indicator ```
  </Accordion>
  <Accordion title="Agent Events">
    ```javascript // Agent execution events 'agent.started' // Agent execution
    began 'agent.progress' // Progress updates 'agent.step.completed' // Step
    finished 'agent.finished' // Agent completed 'agent.error' // Error occurred
    ```
  </Accordion>
  <Accordion title="Data Events">
    ```javascript // Data processing events 'data.sync.started' // Data sync
    began 'data.sync.progress' // Sync progress 'data.sync.completed' // Sync
    finished 'data.analysis.ready' // Analysis completed ```
  </Accordion>
  <Accordion title="UI Events">
    ```javascript // Frontend-specific events 'ui.modal.open' // Modal opened
    'ui.notification.show' // Show notification 'ui.theme.changed' // Theme
    updated 'component.state.updated' // Component state change ```
  </Accordion>
</AccordionGroup>

## Client Implementation

### Basic WebSocket Client

```javascript
class ErroWebSocketClient {
  constructor(resourceType, resourceId) {
    this.resourceType = resourceType;
    this.resourceId = resourceId;
    this.eventHandlers = new Map();
    this.ws = null;
    this.isConnected = false;
  }

  async connect(resumeFromEventId = null) {
    // Get authentication ticket
    const ticket = await this.getTicket();

    // Build WebSocket URL
    let wsUrl = `ws://localhost:4000/websocket/connect?ticket=${ticket}`;
    if (resumeFromEventId) {
      wsUrl += `&resume_from_event_id=${resumeFromEventId}&client_id=${this.clientId}`;
    }

    // Connect
    this.ws = new WebSocket(wsUrl);
    this.setupEventHandlers();
  }

  setupEventHandlers() {
    this.ws.onopen = () => {
      this.isConnected = true;
      this.subscribeToChannel();
    };

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleEvent(data);
    };

    this.ws.onclose = () => {
      this.isConnected = false;
      this.handleReconnection();
    };

    this.ws.onerror = (error) => {
      console.error("WebSocket error:", error);
    };
  }

  subscribeToChannel() {
    this.send({
      type: "subscribe",
      channel: {
        type: this.resourceType,
        resource_id: this.resourceId,
      },
    });
  }

  handleEvent(data) {
    const handler = this.eventHandlers.get(data.type);
    if (handler) {
      handler(data);
    }

    // Also call general handler
    const generalHandler = this.eventHandlers.get("*");
    if (generalHandler) {
      generalHandler(data);
    }
  }

  on(eventType, handler) {
    this.eventHandlers.set(eventType, handler);
  }

  send(message) {
    if (this.isConnected) {
      this.ws.send(JSON.stringify(message));
    }
  }
}
```

### React Hook Integration

```typescript
import { useEffect, useRef, useState } from "react";

interface WebSocketEvent {
  id: string;
  type: string;
  channel: {
    type: string;
    resource_id: string;
  };
  payload: string;
  timestamp: number;
  event_id?: number;
}

export function useWebSocket(resourceType: string, resourceId: string) {
  const [isConnected, setIsConnected] = useState(false);
  const [lastEvent, setLastEvent] = useState<WebSocketEvent | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const eventHandlers = useRef(
    new Map<string, (event: WebSocketEvent) => void>()
  );

  const connect = async (resumeFromEventId?: number) => {
    try {
      // Get ticket
      const response = await fetch("/websocket/ticket", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          resource_type: resourceType,
          resource_id: resourceId,
        }),
      });
      const { ticket } = await response.json();

      // Connect WebSocket
      let wsUrl = `ws://localhost:4000/websocket/connect?ticket=${ticket}`;
      if (resumeFromEventId) {
        wsUrl += `&resume_from_event_id=${resumeFromEventId}&client_id=${Date.now()}`;
      }

      wsRef.current = new WebSocket(wsUrl);

      wsRef.current.onopen = () => {
        setIsConnected(true);
        // Subscribe to channel
        wsRef.current?.send(
          JSON.stringify({
            type: "subscribe",
            channel: { type: resourceType, resource_id: resourceId },
          })
        );
      };

      wsRef.current.onmessage = (event) => {
        const data = JSON.parse(event.data) as WebSocketEvent;
        setLastEvent(data);

        // Call registered handlers
        const handler = eventHandlers.current.get(data.type);
        handler?.(data);

        const generalHandler = eventHandlers.current.get("*");
        generalHandler?.(data);
      };

      wsRef.current.onclose = () => setIsConnected(false);
    } catch (error) {
      console.error("Failed to connect WebSocket:", error);
    }
  };

  const subscribe = (
    eventType: string,
    handler: (event: WebSocketEvent) => void
  ) => {
    eventHandlers.current.set(eventType, handler);
    return () => eventHandlers.current.delete(eventType);
  };

  const send = (message: any) => {
    if (isConnected && wsRef.current) {
      wsRef.current.send(JSON.stringify(message));
    }
  };

  useEffect(() => {
    return () => {
      wsRef.current?.close();
    };
  }, []);

  return { connect, subscribe, send, isConnected, lastEvent };
}
```

## Advanced Features

### Connection Resumption

Resume connections with message history to handle disconnections gracefully:

```javascript
// Store last received event ID
let lastEventId = localStorage.getItem("lastEventId") || 0;

// Connect with resumption
const client = new ErroWebSocketClient("thread", "thread-uuid");
await client.connect(lastEventId);

// Update stored event ID when receiving events
client.on("*", (event) => {
  if (event.event_id) {
    localStorage.setItem("lastEventId", event.event_id.toString());
  }
});
```

### Health Status Tracking

Monitor connection and execution health:

```javascript
client.on("health.status", (event) => {
  const status = JSON.parse(event.payload);
  switch (status.status) {
    case "idle":
      // Connection established, no active operations
      break;
    case "in_progress":
      // Agent or operation is running
      break;
    case "connected":
      // Client connected successfully
      break;
    case "error":
      // Error occurred
      break;
  }
});
```

### Multiple Client Management

Handle multiple clients for the same resource:

```javascript
// Each client gets a unique ID
const clientId = `client_${Date.now()}_${Math.random()}`;

// Clients can coordinate through custom events
client.on("client.joined", (event) => {
  console.log("New client joined:", event.payload);
});

client.on("client.left", (event) => {
  console.log("Client left:", event.payload);
});
```

## Error Handling & Reconnection

### Automatic Reconnection

```javascript
class ResilientWebSocketClient extends ErroWebSocketClient {
  constructor(resourceType, resourceId) {
    super(resourceType, resourceId);
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 1000;
  }

  handleReconnection() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      const delay = Math.min(
        this.reconnectDelay * Math.pow(2, this.reconnectAttempts),
        30000
      );

      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect(this.lastEventId);
      }, delay);
    }
  }

  resetReconnection() {
    this.reconnectAttempts = 0;
  }
}
```

### Error Event Handling

```javascript
client.on("error", (event) => {
  const error = JSON.parse(event.payload);
  console.error("WebSocket error:", error);

  // Handle different error types
  switch (error.type) {
    case "authentication_failed":
      // Refresh tokens and reconnect
      break;
    case "rate_limited":
      // Back off and retry
      break;
    case "resource_not_found":
      // Handle missing resource
      break;
  }
});
```

## Server-Side Broadcasting

### Internal Event Broadcasting

From your backend services, broadcast events to WebSocket clients:

```go
package main

import (
    "encore.app/backend/websocket"
    wsTypes "encore.app/backend/websocket/types"
)

// Broadcast to all clients subscribed to a thread
func broadcastThreadUpdate(threadID string, message string) error {
    channel := wsTypes.Channel{
        Type:       wsTypes.ChannelTypeThread,
        ResourceID: threadID,
    }

    payload := fmt.Sprintf(`{"message": "%s", "timestamp": %d}`, message, time.Now().Unix())

    return websocket.BroadcastEvent(
        wsTypes.EventType("thread.update"),
        channel,
        payload,
        nil, // userID (optional)
        nil, // eventID (optional)
    )
}

// Broadcast custom events
func broadcastCustomEvent(orgID string, eventType string, data interface{}) error {
    channel := wsTypes.Channel{
        Type:       wsTypes.ChannelTypeOrganization,
        ResourceID: orgID,
    }

    payload, _ := json.Marshal(data)

    return websocket.BroadcastEvent(
        wsTypes.EventType(eventType),
        channel,
        string(payload),
        nil,
        nil,
    )
}
```

### Event-Driven Architecture

Integrate with Encore's pub/sub system:

```go
// Subscribe to events and broadcast via WebSocket
var _ = pubsub.NewSubscription(
    events.DatasetStatusChangedTopic, "websocket-dataset-status",
    pubsub.SubscriptionConfig[*events.DatasetStatusChangedEvent]{
        Handler: pubsub.MethodHandler((*Service).handleDatasetStatusChanged),
    },
)

func (svc *Service) handleDatasetStatusChanged(ctx context.Context, event *events.DatasetStatusChangedEvent) error {
    payload := fmt.Sprintf(`{"dataset_id":"%s","status":"%s","event_type":"%s"}`,
        event.DatasetID.String(), event.Status, event.EventType)

    channel := wsTypes.Channel{
        Type:       wsTypes.ChannelTypeDataset,
        ResourceID: event.DatasetID.String(),
    }

    return websocket.BroadcastEvent(
        wsTypes.EventType(event.EventType),
        channel,
        payload,
        &event.UserID,
        nil,
    )
}
```

## Performance Optimization

### Message Buffering

```javascript
class BufferedWebSocketClient {
  constructor(resourceType, resourceId) {
    this.messageBuffer = [];
    this.bufferTimeout = null;
    this.bufferSize = 10;
    this.bufferDelay = 100; // ms
  }

  handleEvent(data) {
    this.messageBuffer.push(data);

    if (this.messageBuffer.length >= this.bufferSize) {
      this.flushBuffer();
    } else if (!this.bufferTimeout) {
      this.bufferTimeout = setTimeout(
        () => this.flushBuffer(),
        this.bufferDelay
      );
    }
  }

  flushBuffer() {
    if (this.bufferTimeout) {
      clearTimeout(this.bufferTimeout);
      this.bufferTimeout = null;
    }

    const messages = this.messageBuffer.splice(0);
    this.processBatchedMessages(messages);
  }

  processBatchedMessages(messages) {
    // Process messages in batch for better performance
    messages.forEach((message) => {
      const handler = this.eventHandlers.get(message.type);
      handler?.(message);
    });
  }
}
```

### Connection Monitoring

```javascript
// Monitor connection quality
setInterval(() => {
  if (client.isConnected) {
    client.send({
      type: "ping",
      timestamp: Date.now(),
    });
  }
}, 30000); // Ping every 30 seconds

client.on("pong", (event) => {
  const latency = Date.now() - JSON.parse(event.payload).timestamp;
  console.log(`WebSocket latency: ${latency}ms`);
});
```

## Best Practices

<Tabs>
  <Tab title="Connection Management">
    - Use connection pooling for multiple resources - Implement exponential
    backoff for reconnections - Store connection state for resumption - Clean up
    connections when components unmount
  </Tab>
  <Tab title="Event Handling">
    - Use specific event types for better organization - Implement event
    filtering on the client side - Batch process high-frequency events - Handle
    event ordering for time-sensitive operations
  </Tab>
  <Tab title="Error Recovery">
    - Always implement connection resumption - Handle authentication token
    expiration - Provide fallback for missing events - Log connection issues for
    debugging
  </Tab>
  <Tab title="Performance">
    - Limit concurrent connections per user - Use message compression for large
    payloads - Implement client-side caching for frequently accessed data -
    Monitor connection health and quality
  </Tab>
</Tabs>

WebSocket streaming in Erdo provides a robust foundation for building real-time, interactive applications with sophisticated error handling and performance optimization capabilities.
