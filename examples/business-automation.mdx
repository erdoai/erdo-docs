---
title: "Business Automation Examples"
description: "Real-world examples of business process automation with AI agents"
---

# Business Automation Examples

Comprehensive examples showing how to automate common business processes using AI agents. These examples demonstrate real-world patterns for document processing, customer onboarding, workflow automation, and more.

## Email Processing & Response Automation

Automate email categorization and intelligent response generation:

```python
from erdo import Agent
from erdo.actions import llm, memory, utils
from erdo.conditions import IsSuccess, TextEquals, TextContains, GreaterThan

email_processor = Agent(
    name="intelligent_email_processor",
    description="Automatically processes and responds to emails with context awareness"
)

# Step 1: Classify incoming email
classify_step = email_processor.step(
    llm.message(
        model="claude-sonnet-4",
        query="Classify this email: {{email_content}}",
        system_prompt="You are an email classification expert. Analyze emails for category, urgency, and required actions.",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "category": {"type": "string", "enum": ["support", "sales", "general"]},
                    "urgency": {"type": "string", "enum": ["low", "medium", "high", "urgent"]},
                    "sentiment": {"type": "string", "enum": ["positive", "neutral", "negative"]},
                    "requires_response": {"type": "boolean"},
                    "key_topics": {"type": "array", "items": {"type": "string"}}
                }
            }
        }
    )
)

# Step 2: Search for relevant context
context_step = email_processor.step(
    memory.search(
        query="{{email_sender}} {{classify_step.output.key_topics}}",
        limit=5,
        organization_scope="specific"
    ),
    depends_on=classify_step
)

# Step 3: Generate intelligent response
response_step = email_processor.step(
    llm.message(
        model="claude-sonnet-4",
        query="Generate a professional response to this {{classify_step.output.category}} email: {{email_content}}",
        context="Previous interactions: {{context_step.output.memories}}",
        system_prompt="You are a professional customer service representative. Generate helpful, accurate responses."
    ),
    depends_on=[classify_step, context_step]
)

# Handle urgent emails immediately
classify_step.on(
    IsSuccess() & TextEquals("urgency", "urgent"),
    utils.send_status(
        status="urgent_email",
        message="URGENT EMAIL DETECTED - Immediate attention required",
        priority="critical",
        email_details="{{email_content}}"
    )
)

# Auto-respond to routine inquiries
@response_step.when(
    IsSuccess() &
    TextEquals("category", "general") &
    TextContains("sentiment", "positive") &
    GreaterThan("confidence", "0.8")
)
def auto_send_routine_response(result):
    """Auto-send responses for routine, positive inquiries."""
    return utils.send_status(
        status="auto_responded",
        message="Automatic response sent",
        response_content=result.output.response
    )

# Flag complex support issues for human review
@response_step.when(
    IsSuccess() &
    TextEquals("category", "support") &
    (TextContains("sentiment", "negative") | TextEquals("urgency", "high"))
)
def escalate_complex_support(result):
    """Escalate complex support issues to human agents."""
    return memory.store(memory={
        "content": f"Complex support case: {result.output.analysis}",
        "type": "escalated_support",
        "tags": ["support", "escalated", "{{email_sender}}"],
        "extra": {
            "original_email": "{{email_content}}",
            "suggested_response": result.output.response,
            "urgency": "{{classify_step.output.urgency}}"
        }
    })

# Store all email interactions for context
@response_step.when(IsSuccess())
def store_email_interaction(result):
    """Store email interaction for future context."""
    return memory.store(memory={
        "content": f"Email from {{email_sender}}: {{email_content}}\nResponse: {result.output.response}",
        "type": "email_interaction",
        "tags": ["email", "{{classify_step.output.category}}", "{{email_sender}}"],
        "searchable_texts": ["{{email_content}}", result.output.response]
    })
```

## Document Processing & Analysis

Intelligent document processing with AI-powered extraction and validation:

```python
from erdo.actions import codeexec, webparser

document_processor = Agent(
    name="intelligent_document_processor",
    description="Processes various document types with AI-powered extraction and validation"
)

# Step 1: Analyze document type and structure
analysis_step = document_processor.step(
    llm.message(
        model="claude-sonnet-4",
        query="Analyze this document and determine processing approach: {{document_content}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "document_type": {"type": "string"},
                    "confidence": {"type": "number"},
                    "key_sections": {"type": "array"},
                    "processing_complexity": {"type": "string", "enum": ["simple", "moderate", "complex"]},
                    "extraction_fields": {"type": "array"}
                }
            }
        }
    )
)

# Step 2: Extract structured data based on document type
extraction_step = document_processor.step(
    llm.message(
        model="claude-sonnet-4",
        query="Extract key information from this {{analysis_step.output.document_type}}: {{document_content}}",
        system_prompt="You are a document processing expert. Extract accurate, structured information.",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "extracted_data": {"type": "object"},
                    "confidence_scores": {"type": "object"},
                    "validation_flags": {"type": "array"},
                    "missing_fields": {"type": "array"}
                }
            }
        }
    ),
    depends_on=analysis_step
)

# Step 3: Validate extracted data
validation_step = document_processor.step(
    codeexec.execute(
        code_files=[{
            "filename": "document_validator.py",
            "content": """
import json
import re
from datetime import datetime

def validate_document_data(extracted_data, document_type):
    validation_results = {
        "is_valid": True,
        "errors": [],
        "warnings": [],
        "completeness_score": 0.0
    }

    # Validate based on document type
    if document_type == "invoice":
        required_fields = ["invoice_number", "date", "amount", "vendor"]
        for field in required_fields:
            if field not in extracted_data or not extracted_data[field]:
                validation_results["errors"].append(f"Missing required field: {field}")
                validation_results["is_valid"] = False

    elif document_type == "contract":
        required_fields = ["parties", "effective_date", "terms"]
        for field in required_fields:
            if field not in extracted_data:
                validation_results["errors"].append(f"Missing required field: {field}")
                validation_results["is_valid"] = False

    # Calculate completeness score
    total_fields = len(extracted_data)
    empty_fields = sum(1 for v in extracted_data.values() if not v)
    validation_results["completeness_score"] = (total_fields - empty_fields) / total_fields if total_fields > 0 else 0

    return validation_results

# Execute validation
extracted_data = {{extraction_step.output.extracted_data}}
document_type = "{{analysis_step.output.document_type}}"
result = validate_document_data(extracted_data, document_type)
print(json.dumps(result))
"""
        }]
    ),
    depends_on=extraction_step
)

# Handle simple documents with high confidence
@extraction_step.when(
    IsSuccess() &
    TextEquals("processing_complexity", "simple") &
    GreaterThan("confidence", "0.9")
)
def auto_process_simple_documents(result):
    """Auto-process simple, high-confidence documents."""
    return utils.send_status(
        status="auto_processed",
        message="Document automatically processed and filed",
        extracted_data=result.output.extracted_data
    )

# Handle complex documents requiring review
@analysis_step.when(
    IsSuccess() &
    (TextEquals("processing_complexity", "complex") | LessThan("confidence", "0.7"))
)
def flag_complex_documents(result):
    """Flag complex or low-confidence documents for human review."""
    return memory.store(memory={
        "content": f"Complex document requiring review: {result.output.document_type}",
        "type": "document_review_required",
        "tags": ["document", "review", "complex"],
        "extra": {
            "document_type": result.output.document_type,
            "complexity": result.output.processing_complexity,
            "confidence": result.output.confidence
        }
    })

# Store successfully validated documents
@validation_step.when(IsSuccess() & TextEquals("is_valid", "true"))
def store_validated_document(result):
    """Store successfully validated documents."""
    return memory.store(memory={
        "content": "{{extraction_step.output.extracted_data}}",
        "type": "validated_document",
        "tags": ["document", "{{analysis_step.output.document_type}}", "validated"],
        "extra": {
            "validation_results": result.output,
            "completeness_score": result.output.completeness_score,
            "processing_date": "{{current_timestamp}}"
        }
    })

# Handle validation failures
@validation_step.when(IsSuccess() & TextEquals("is_valid", "false"))
def handle_validation_failure(result):
    """Handle documents that fail validation."""
    return utils.send_status(
        status="validation_failed",
        message="Document validation failed - manual review required",
        errors=result.output.errors,
        warnings=result.output.warnings
    )
```

## Invoice Processing Workflow

Complete invoice processing automation with approval workflows:

```python
invoice_processor = Agent(
    name="automated_invoice_processor",
    description="Processes invoices from receipt to payment approval"
)

# Step 1: Extract invoice data
extract_step = invoice_processor.step(
    llm.message(
        model="claude-sonnet-4",
        query="Extract all relevant information from this invoice: {{invoice_image}}",
        system_prompt="You are an accounting expert. Extract accurate financial information from invoices.",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "vendor_name": {"type": "string"},
                    "invoice_number": {"type": "string"},
                    "invoice_date": {"type": "string"},
                    "due_date": {"type": "string"},
                    "total_amount": {"type": "number"},
                    "line_items": {"type": "array"},
                    "tax_amount": {"type": "number"},
                    "payment_terms": {"type": "string"}
                }
            }
        }
    )
)

# Step 2: Validate against purchase orders
po_validation = invoice_processor.step(
    codeexec.execute(
        code_files=[{
            "filename": "po_validator.py",
            "content": """
import json

def validate_against_po(invoice_data):
    # Simulate PO validation logic
    validation_results = {
        "po_match": True,
        "amount_variance": 0.0,
        "approval_required": False,
        "approval_level": "auto"
    }

    # Check if amount exceeds approval threshold
    if invoice_data["total_amount"] > 10000:
        validation_results["approval_required"] = True
        validation_results["approval_level"] = "manager"

    if invoice_data["total_amount"] > 50000:
        validation_results["approval_level"] = "director"

    return validation_results

invoice_data = {{extract_step.output}}
result = validate_against_po(invoice_data)
print(json.dumps(result))
"""
        }]
    ),
    depends_on=extract_step
)

# Step 3: Risk assessment
risk_assessment = invoice_processor.step(
    llm.message(
        model="claude-sonnet-4",
        query="Assess the risk level of this invoice: {{extract_step.output}}",
        system_prompt="You are a financial risk analyst. Evaluate invoices for potential fraud or errors.",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "risk_score": {"type": "number", "minimum": 0, "maximum": 1},
                    "risk_factors": {"type": "array"},
                    "recommendation": {"type": "string"},
                    "requires_investigation": {"type": "boolean"}
                }
            }
        }
    ),
    depends_on=extract_step
)

# Auto-approve low-risk, low-amount invoices
po_validation.on(
    IsSuccess() &
    TextEquals("po_match", "true") &
    TextEquals("approval_required", "false"),
    utils.send_status(
        status="auto_approved",
        message="Invoice auto-approved for payment",
        invoice_data="{{extract_step.output}}"
    ),
    memory.store(memory={
        "content": "Auto-approved invoice: {{extract_step.output.invoice_number}}",
        "type": "approved_invoice",
        "tags": ["invoice", "auto-approved", "{{extract_step.output.vendor_name}}"]
    })
)

# Route for manager approval
@po_validation.when(
    IsSuccess() &
    TextEquals("approval_required", "true") &
    TextEquals("approval_level", "manager")
)
def route_to_manager(result):
    """Route invoice to manager for approval."""
    return utils.send_status(
        status="pending_manager_approval",
        message="Invoice requires manager approval",
        invoice_details="{{extract_step.output}}",
        amount="{{extract_step.output.total_amount}}"
    )

# Escalate high-risk invoices
@risk_assessment.when(IsSuccess() & GreaterThan("risk_score", "0.7"))
def escalate_high_risk_invoice(result):
    """Escalate high-risk invoices for investigation."""
    return utils.send_status(
        status="high_risk_detected",
        message="High-risk invoice detected - investigation required",
        priority="urgent",
        risk_factors=result.output.risk_factors,
        invoice_data="{{extract_step.output}}"
    )

# Store all processed invoices for audit trail
@extract_step.when(IsSuccess())
def create_audit_trail(result):
    """Create audit trail for all processed invoices."""
    return memory.store(memory={
        "content": f"Invoice processed: {result.output.invoice_number} from {result.output.vendor_name}",
        "type": "invoice_audit_trail",
        "tags": ["audit", "invoice", result.output.vendor_name],
        "extra": {
            "invoice_data": result.output,
            "processing_timestamp": "{{current_timestamp}}",
            "processor": "automated_invoice_processor"
        }
    })
```

## Customer Onboarding Automation

Streamline customer onboarding with intelligent document verification and workflow management:

```python
onboarding_agent = Agent(
    name="customer_onboarding_automation",
    description="Automates customer onboarding process with document verification and compliance checks"
)

# Step 1: Analyze onboarding documents
document_analysis = onboarding_agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Analyze customer onboarding documents: {{documents}}",
        system_prompt="You are a compliance expert. Analyze documents for completeness and compliance requirements.",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "document_types": {"type": "array"},
                    "completeness_score": {"type": "number"},
                    "missing_documents": {"type": "array"},
                    "compliance_status": {"type": "string"},
                    "risk_indicators": {"type": "array"}
                }
            }
        }
    )
)

# Step 2: Verify customer identity
identity_verification = onboarding_agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "identity_verifier.py",
            "content": """
import json
import random

def verify_customer_identity(customer_data):
    # Simulate identity verification process
    verification_result = {
        "identity_verified": random.choice([True, False]),
        "verification_score": random.uniform(0.7, 1.0),
        "verification_method": "document_analysis",
        "flags": []
    }

    # Add some realistic flags
    if verification_result["verification_score"] < 0.8:
        verification_result["flags"].append("low_confidence_match")

    if not verification_result["identity_verified"]:
        verification_result["flags"].append("identity_mismatch")

    return verification_result

customer_data = {{customer_info}}
result = verify_customer_identity(customer_data)
print(json.dumps(result))
"""
        }]
    )
)

# Step 3: Compliance check
compliance_check = onboarding_agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Perform compliance check for customer: {{customer_info}}",
        system_prompt="You are a regulatory compliance expert. Check for AML, KYC, and other regulatory requirements.",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "aml_status": {"type": "string"},
                    "kyc_status": {"type": "string"},
                    "sanctions_check": {"type": "string"},
                    "overall_compliance": {"type": "string"},
                    "required_actions": {"type": "array"}
                }
            }
        }
    )
)

# Step 4: Generate welcome package
welcome_package = onboarding_agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Generate personalized welcome package for: {{customer_info}}",
        system_prompt="Create a warm, professional welcome message with relevant next steps.",
        context="Account setup: {{account_details}}"
    ),
    depends_on=[document_analysis, identity_verification, compliance_check]
)

# Auto-approve customers with complete documentation and clean compliance
document_analysis.on(
    IsSuccess() &
    GreaterThan("completeness_score", "0.95") &
    TextEquals("compliance_status", "compliant"),
    identity_verification.on(
        IsSuccess() &
        TextEquals("identity_verified", "true") &
        GreaterThan("verification_score", "0.9"),
        utils.send_status(
            status="auto_approved",
            message="Customer automatically approved for onboarding"
        )
    )
)

# Handle incomplete documentation
@document_analysis.when(IsSuccess() & LessThan("completeness_score", "0.8"))
def request_additional_documents(result):
    """Request additional documents from customer."""
    return utils.send_status(
        status="additional_documents_required",
        message="Additional documentation required to complete onboarding",
        missing_documents=result.output.missing_documents,
        customer_id="{{customer_info.id}}"
    )

# Flag compliance issues
@compliance_check.when(IsSuccess() & ~TextEquals("overall_compliance", "approved"))
def flag_compliance_issues(result):
    """Flag customers with compliance issues."""
    return memory.store(memory={
        "content": f"Compliance issues detected for customer {{customer_info.id}}",
        "type": "compliance_flag",
        "tags": ["compliance", "onboarding", "{{customer_info.id}}"],
        "extra": {
            "compliance_status": result.output.overall_compliance,
            "required_actions": result.output.required_actions,
            "aml_status": result.output.aml_status,
            "kyc_status": result.output.kyc_status
        }
    })

# Send welcome package to approved customers
@welcome_package.when(IsSuccess())
def send_welcome_package(result):
    """Send welcome package to newly onboarded customers."""
    return utils.send_status(
        status="welcome_package_sent",
        message="Welcome package sent to customer",
        customer_id="{{customer_info.id}}",
        welcome_content=result.output.welcome_message
    )

# Store successful onboarding records
welcome_package.on(
    IsSuccess(),
    memory.store(memory={
        "content": "Customer successfully onboarded: {{customer_info.id}}",
        "type": "successful_onboarding",
        "tags": ["onboarding", "success", "{{customer_info.id}}"],
        "extra": {
            "customer_data": "{{customer_info}}",
            "onboarding_date": "{{current_timestamp}}",
            "compliance_status": "{{compliance_check.output.overall_compliance}}"
        }
    })
)
```

## Key Patterns and Best Practices

### Error Handling Strategies

```python
# Comprehensive error handling with fallbacks
@step.when(IsError())
def handle_processing_error(error):
    """Handle processing errors with appropriate fallbacks."""
    if "timeout" in error.message.lower():
        return utils.send_status(
            status="timeout_retry",
            message="Processing timeout - retrying with extended timeout"
        )
    elif "validation" in error.message.lower():
        return utils.send_status(
            status="validation_error",
            message="Validation failed - manual review required"
        )
    else:
        return utils.send_status(
            status="general_error",
            message=f"Processing failed: {error.message}"
        )
```

### Conditional Workflow Routing

```python
# Route workflows based on business rules
@analysis_step.when(IsSuccess() & GreaterThan("amount", "10000"))
def route_high_value(result):
    """Route high-value transactions for additional approval."""
    return utils.send_status(
        status="high_value_approval_required",
        message="High-value transaction requires additional approval"
    )

@analysis_step.when(IsSuccess() & TextContains("category", "international"))
def route_international(result):
    """Route international transactions for compliance review."""
    return utils.send_status(
        status="international_compliance_review",
        message="International transaction requires compliance review"
    )
```

### Audit Trail Management

```python
# Maintain comprehensive audit trails
@step.when(IsSuccess())
def create_audit_record(result):
    """Create audit record for all successful operations."""
    return memory.store(memory={
        "content": f"Operation completed: {result.output.operation_type}",
        "type": "audit_record",
        "tags": ["audit", "{{operation_type}}", "{{user_id}}"],
        "extra": {
            "operation_details": result.output,
            "timestamp": "{{current_timestamp}}",
            "user_id": "{{user_id}}",
            "system_version": "{{system_version}}"
        }
    })
```

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Data Analysis Examples"
    icon="chart-line"
    href="/examples/data-analysis"
  >
    Explore AI-powered data analysis and insights generation
  </Card>
  <Card title="Core Concepts" icon="book" href="/concepts/overview">
    Learn about agents, steps, actions, and result handlers
  </Card>
  <Card title="SDK Reference" icon="code" href="/sdk/overview">
    Complete Python SDK documentation and API reference
  </Card>
  <Card title="Pre-built Agents" icon="robot" href="/agents/data-analyst">
    Leverage ready-made automation solutions
  </Card>
</CardGroup>
