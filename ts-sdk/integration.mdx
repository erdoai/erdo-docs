---
title: "Integration Patterns"
description: "Common patterns for integrating Erdo into your applications"
---

# Integration Patterns

This guide covers common patterns for integrating Erdo into different application architectures.

## Next.js App Router

### Server Component

Fetch data on the server:

```tsx
// app/analysis/page.tsx
import { ErdoClient } from '@erdoai/server';

export default async function AnalysisPage() {
  const client = new ErdoClient({
    authToken: process.env.ERDO_AUTH_TOKEN,
  });

  const result = await client.invoke('data-analyst', {
    messages: [{ role: 'user', content: 'Generate a summary report' }],
  });

  return (
    <div>
      {result.result?.output?.content?.map((item, i) => (
        <div key={i}>{JSON.stringify(item)}</div>
      ))}
    </div>
  );
}
```

### Client Component with Streaming

<Warning>
Never expose your API key to the browser. Choose one of two secure streaming patterns below.
</Warning>

There are two ways to stream Erdo results to your frontend:

| Pattern | How it works | Best for |
|---------|--------------|----------|
| **Ephemeral Tokens** | Backend creates a short-lived token, frontend streams directly from Erdo API | Lower latency, simpler backend |
| **Proxy Streaming** | Backend proxies the SSE stream | Strict CSP requirements, custom logging/rate limiting |

#### Pattern 1: Ephemeral Tokens (Recommended)

Your backend creates a scoped, short-lived token. The frontend uses it to invoke directly.

```tsx
// app/api/authorize/route.ts (SERVER)
import { ErdoClient } from '@erdoai/server';

const client = new ErdoClient({ authToken: process.env.ERDO_AUTH_TOKEN });

export async function POST(request: Request) {
  const { botId } = await request.json();

  // Add your own RBAC logic here
  // if (!user.canAccess(botId)) return Response.json({ error: 'Forbidden' }, { status: 403 });

  const { token, tokenId, expiresAt } = await client.createToken({
    botIds: [botId],  // Bot UUIDs
    expiresInSeconds: 3600, // 1 hour
  });

  return Response.json({ token, tokenId, expiresAt });
}
```

```tsx
// app/chat/page.tsx (CLIENT)
'use client';

import { useState, useRef, useCallback, useMemo } from 'react';
import { ErdoClient } from '@erdoai/server';
import { ErdoProvider, useInvocation, Content } from '@erdoai/ui';

function ChatInterface() {
  const [query, setQuery] = useState('');
  const { result, isStreaming, invoke } = useInvocation();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await invoke('data-analyst', {
      messages: [{ role: 'user', content: query }],
    });
  };

  const contents = result?.result?.output?.content || [];

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input value={query} onChange={(e) => setQuery(e.target.value)} />
        <button disabled={isStreaming}>{isStreaming ? 'Analyzing...' : 'Send'}</button>
      </form>
      {contents.map((item, i) => <Content key={i} content={item} />)}
    </div>
  );
}

export default function ChatPage() {
  const [client, setClient] = useState<ErdoClient | null>(null);
  const tokenRef = useRef<{ token: string; expiresAt: Date; endpoint: string } | null>(null);

  const authenticate = useCallback(async () => {
    if (tokenRef.current && new Date(tokenRef.current.expiresAt) > new Date()) {
      return;
    }
    const res = await fetch('/api/authorize', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ botId: 'uuid-of-data-analyst-bot' }),  // Bot UUID
    });
    const { token, expiresAt, endpoint } = await res.json();
    tokenRef.current = { token, expiresAt: new Date(expiresAt), endpoint };
    setClient(new ErdoClient({ endpoint, token }));
  }, []);

  const config = useMemo(() => ({
    baseUrl: tokenRef.current?.endpoint || '',
    client: client || undefined,
  }), [client]);

  if (!client) {
    return <button onClick={authenticate}>Connect</button>;
  }

  return (
    <ErdoProvider config={config}>
      <ChatInterface />
    </ErdoProvider>
  );
}
```

#### Pattern 2: Proxy Streaming

Your backend proxies all requests. The API key never leaves your server.

```tsx
// app/api/invoke/route.ts (SERVER)
import { ErdoClient } from '@erdoai/server';

const client = new ErdoClient({ authToken: process.env.ERDO_AUTH_TOKEN });

export async function POST(request: Request) {
  const { botKey, messages, datasets } = await request.json();

  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      try {
        for await (const event of client.invokeStream(botKey, { messages, datasets })) {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify(event)}\n\n`));
        }
        controller.enqueue(encoder.encode('data: [DONE]\n\n'));
      } finally {
        controller.close();
      }
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
    },
  });
}
```

```tsx
// app/chat/page.tsx (CLIENT)
'use client';

import { useMemo } from 'react';
import { ErdoClient } from '@erdoai/server';
import { ErdoProvider, useInvocation, Content } from '@erdoai/ui';
import { useState } from 'react';

function ChatInterface() {
  const [query, setQuery] = useState('');
  const { result, isStreaming, invoke } = useInvocation();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await invoke('data-analyst', {
      messages: [{ role: 'user', content: query }],
    });
  };

  const contents = result?.result?.output?.content || [];

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input value={query} onChange={(e) => setQuery(e.target.value)} />
        <button disabled={isStreaming}>{isStreaming ? 'Analyzing...' : 'Send'}</button>
      </form>
      {contents.map((item, i) => <Content key={i} content={item} />)}
    </div>
  );
}

export default function ChatPage() {
  // Point ErdoClient to your proxy endpoint
  const client = useMemo(() => new ErdoClient({
    endpoint: '/api',  // Your proxy
    authToken: 'proxy',  // Proxy handles auth
  }), []);

  const config = useMemo(() => ({
    baseUrl: '/api',
    client,
  }), [client]);

  return (
    <ErdoProvider config={config}>
      <ChatInterface />
    </ErdoProvider>
  );
}
```

## Vercel AI SDK

Use Erdo as a tool in your AI chat application:

```tsx
// app/api/chat/route.ts
import { openai } from '@ai-sdk/openai';
import { streamText, tool } from 'ai';
import { z } from 'zod';
import { ErdoClient } from '@erdoai/server';

const erdoClient = new ErdoClient({
  authToken: process.env.ERDO_AUTH_TOKEN,
});

export async function POST(req: Request) {
  const { messages } = await req.json();

  const result = streamText({
    model: openai('gpt-4'),
    messages,
    tools: {
      analyzeData: tool({
        description: 'Analyze data and create visualizations using Erdo',
        parameters: z.object({
          query: z.string().describe('The data analysis question'),
        }),
        execute: async ({ query }) => {
          const result = await erdoClient.invoke('data-analyst', {
            messages: [{ role: 'user', content: query }],
          });
          return result;
        },
      }),
    },
  });

  return result.toDataStreamResponse();
}
```

### Rendering Tool Results

```tsx
// components/chat.tsx
'use client';

import { useChat } from 'ai/react';
import { Content } from '@erdoai/ui';

export function Chat() {
  const { messages, input, handleInputChange, handleSubmit } = useChat();

  return (
    <div>
      {messages.map((m) => (
        <div key={m.id}>
          {m.role === 'user' ? 'User: ' : 'AI: '}
          {m.content}

          {/* Render Erdo tool results */}
          {m.toolInvocations?.map((tool, i) => {
            if (tool.toolName === 'analyzeData' && tool.result) {
              return (
                <div key={i}>
                  {tool.result.result?.output?.content?.map((item, j) => (
                    <Content key={j} content={item} />
                  ))}
                </div>
              );
            }
          })}
        </div>
      ))}

      <form onSubmit={handleSubmit}>
        <input value={input} onChange={handleInputChange} />
        <button type="submit">Send</button>
      </form>
    </div>
  );
}
```

## Express.js / Node.js

### REST API Endpoint

```typescript
// server.ts
import express from 'express';
import { ErdoClient } from '@erdoai/server';

const app = express();
const client = new ErdoClient({
  authToken: process.env.ERDO_AUTH_TOKEN,
});

app.use(express.json());

app.post('/api/analyze', async (req, res) => {
  const { query } = req.body;

  try {
    const result = await client.invoke('data-analyst', {
      messages: [{ role: 'user', content: query }],
    });
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: 'Analysis failed' });
  }
});

app.listen(3000);
```

### SSE Streaming Endpoint

```typescript
app.get('/api/analyze/stream', async (req, res) => {
  const query = req.query.q as string;

  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  try {
    for await (const event of client.invokeStream('data-analyst', {
      messages: [{ role: 'user', content: query }],
    })) {
      res.write(`data: ${JSON.stringify(event)}\n\n`);
    }
  } catch (error) {
    res.write(`data: ${JSON.stringify({ type: 'error', payload: error })}\n\n`);
  }

  res.end();
});
```

## Proxying Through Your Backend

For B2B applications, you may want to proxy Erdo API requests through your own backend rather than having the client call `api.erdo.ai` directly. This approach:

- Keeps your Erdo API key server-side only
- Avoids CSP configuration for `api.erdo.ai`
- Allows you to add custom authentication, logging, or rate limiting

### Option 1: Custom Endpoint

Point the SDK to your own API endpoint:

```typescript
// Server-side client
const client = new ErdoClient({
  authToken: process.env.ERDO_AUTH_TOKEN,
  endpoint: 'https://your-backend.com/api/erdo',  // Your proxy
});

// Or via environment variable
// ERDO_ENDPOINT=https://your-backend.com/api/erdo
```

```tsx
// UI provider
<ErdoProvider
  config={{
    baseUrl: 'https://your-backend.com/api/erdo',
    authToken: userSessionToken,  // Your app's auth, not Erdo key
  }}
>
  {children}
</ErdoProvider>
```

Your backend then forwards requests to `api.erdo.ai`:

```typescript
// Your backend proxy endpoint
app.all('/api/erdo/*', async (req, res) => {
  const erdoPath = req.path.replace('/api/erdo', '');
  const response = await fetch(`https://api.erdo.ai${erdoPath}`, {
    method: req.method,
    headers: {
      'Authorization': `Bearer ${process.env.ERDO_AUTH_TOKEN}`,
      'Content-Type': 'application/json',
    },
    body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined,
  });

  // Forward the response (including SSE streams)
  res.status(response.status);
  response.body?.pipeTo(new WritableStream({
    write: (chunk) => res.write(chunk),
    close: () => res.end(),
  }));
});
```

### Option 2: Custom Data Fetcher

For more control over how data is fetched (e.g., using a typed API client), provide a custom `dataFetcher`:

```tsx
// lib/erdo-fetcher.ts - Create ONCE outside components
import { DataFetcher } from '@erdoai/ui';

export const erdoDataFetcher: DataFetcher = {
  fetchDatasetContents: async (slug, invocationId) => {
    // Use your own API client
    const res = await fetch(`/api/datasets/${slug}?invocationId=${invocationId}`);
    return res.json();
  },
};
```

```tsx
// providers/erdo-provider.tsx
import { ErdoProvider } from '@erdoai/ui';
import { erdoDataFetcher } from '../lib/erdo-fetcher';

export function AppProvider({ children }) {
  return (
    <ErdoProvider
      config={{
        baseUrl: '/api',
        dataFetcher: erdoDataFetcher,
      }}
    >
      {children}
    </ErdoProvider>
  );
}
```

<Note>
When using a custom `dataFetcher`, the `baseUrl` is still used by the `useInvocation` hook. Only `fetchDatasetContents` calls are overridden.
</Note>

## Error Handling

### Client-Side Error Boundary

```tsx
import { ErrorBoundary } from '@erdoai/ui';

function App() {
  return (
    <ErrorBoundary fallback={<div>Something went wrong</div>}>
      <ChatInterface />
    </ErrorBoundary>
  );
}
```

### Hook-Level Error Handling

```tsx
const { error, invoke } = useInvocation({
  onError: (err) => {
    // Log to error tracking service
    console.error('Invocation failed:', err);
    toast.error('Analysis failed. Please try again.');
  },
});
```

## Authentication

### API Key (Server-Side)

Store your API key securely in environment variables:

```bash
# .env
ERDO_AUTH_TOKEN=your-api-key
```

```typescript
// Only use on server-side
const client = new ErdoClient({
  authToken: process.env.ERDO_AUTH_TOKEN,
});
```

### Client-Side Authentication

<Warning>
Never expose API keys to the browser. Use **ephemeral tokens** or **proxy streaming** instead.
</Warning>

For client-side usage, you have two secure options:

1. **Ephemeral Tokens**: Your backend creates a short-lived, scoped token using `createToken()`. The frontend uses this token to invoke directly. See [Client Component with Streaming](#client-component-with-streaming) above.

2. **Proxy Streaming**: Your backend proxies all requests to the Erdo API. The API key never leaves your server. See [Proxying Through Your Backend](#proxying-through-your-backend) below.

### Scoped Tokens (B2B2C)

For B2B2C applications where your customers need to expose Erdo agents and datasets to their end users, use scoped tokens. Scoped tokens are:

- **Short-lived**: Expire after 1-24 hours (configurable)
- **Scoped**: Only grant access to specific bots and datasets
- **User-bound**: Can be linked to your external user ID for thread management

This pattern is ideal for:
- SaaS products embedding AI agents for their customers
- Dashboards where end users should only access specific bots/datasets
- Applications requiring fine-grained, temporary access control

#### Creating Scoped Tokens (Backend)

Create a scoped token from your backend using `createToken()`:

```typescript
// Your backend API route
import { ErdoClient } from '@erdoai/server';

const client = new ErdoClient({
  authToken: process.env.ERDO_AUTH_TOKEN,
});

app.post('/api/erdo-token', async (req, res) => {
  // Create a scoped token for this user
  const { token, tokenId, expiresAt } = await client.createToken({
    botIds: ['uuid-of-data-analyst'],      // Bot UUIDs the user can access
    datasetIds: ['dataset-uuid-1'],        // Datasets the user can query
    externalUserId: req.user.id,           // Links token to your user for thread access
    expiresInSeconds: 3600,                // 1 hour
  });

  // Return the token to your frontend
  res.json({ token, tokenId, expiresAt });
});
```

**Thread access options:**

- **`externalUserId`** (recommended): Threads created by the token holder are automatically accessible. The user can list, view, and continue their own threads across sessions.

- **`threadIds`**: Grant access to specific pre-existing threads. Useful when you want to give a user access to threads they didn't create (e.g., shared conversations).

```typescript
// Grant access to specific threads
const { token, tokenId } = await client.createToken({
  botIds: ['uuid-of-data-analyst'],  // Bot UUIDs
  threadIds: ['thread-uuid-1', 'thread-uuid-2'],  // Pre-existing threads
  expiresInSeconds: 3600,
});
```

#### Using Scoped Tokens (Frontend)

Pass the scoped token to `ErdoProvider`:

```tsx
'use client';

import { ErdoProvider, DatasetChart } from '@erdoai/ui';
import { useEffect, useState } from 'react';

function Dashboard() {
  const [token, setToken] = useState<string | null>(null);

  useEffect(() => {
    // Fetch scoped token from your backend
    fetch('/api/erdo-token', { method: 'POST' })
      .then(res => res.json())
      .then(data => setToken(data.token));
  }, []);

  if (!token) return <div>Loading...</div>;

  return (
    <ErdoProvider
      config={{
        baseUrl: 'https://api.erdo.ai',
        token,  // Use scoped token instead of authToken
      }}
    >
      <DatasetChart
        chartType="bar"
        title="Sales Report"
        invocationId="inv-123"
        datasetSlugs={['sales-data']}
        xAxis={{ key: 'date', label: 'Date' }}
        yAxes={[{ key: 'revenue', label: 'Revenue' }]}
        series={[{ key: 'revenue', name: 'Revenue', color: '#3b82f6', datasetSlug: 'sales-data' }]}
      />
    </ErdoProvider>
  );
}
```

#### Using Threads with Scoped Tokens

When a token is created with `externalUserId`, users can create and manage persistent conversation threads:

```typescript
import { ErdoClient } from '@erdoai/server';

// Client-side: Use the scoped token
const client = new ErdoClient({
  endpoint: 'https://api.erdo.ai',
  token: scopedToken,
});

// Create a thread for this user
const thread = await client.createThread({ name: 'Data Analysis' });

// Send messages and stream responses
for await (const event of client.sendMessage(thread.id, {
  content: 'What were our top products last quarter?',
  botKey: 'my-org.data-analyst',
})) {
  console.log(event.type, event.payload);
}

// List user's threads
const { threads } = await client.listThreads();
```

#### Token API Reference

**CreateTokenParams:**
```typescript
interface CreateTokenParams {
  botIds?: string[];         // Bot UUIDs the token can access
  datasetIds?: string[];     // Dataset IDs the token can query
  threadIds?: string[];      // Thread IDs the token can access
  externalUserId?: string;   // Your user ID (enables thread management)
  expiresInSeconds?: number; // Token lifetime (default: 3600)
}
```

**TokenResponse:**
```typescript
interface TokenResponse {
  tokenId: string;    // Token ID (for revocation)
  token: string;      // The scoped token
  expiresAt: string;  // ISO timestamp when token expires
}
```

<Note>
Scoped tokens are more secure than API keys for client-side use because they:
- Expire automatically
- Only grant access to specific bots and datasets
- Can be linked to external users for personalized thread access
</Note>

## Content Security Policy (CSP)

If your application uses Content Security Policy headers, you'll need to allow connections to the Erdo API for the UI components to fetch data.

### Required Directives

Add the following to your CSP configuration:

```
connect-src 'self' https://api.erdo.ai;
```

This allows the `@erdoai/ui` components to:
- Fetch dataset contents for rendering charts and tables
- Stream agent invocation results in real-time

### Next.js Configuration

```javascript
// next.config.js
const securityHeaders = [
  {
    key: 'Content-Security-Policy',
    value: `
      default-src 'self';
      script-src 'self' 'unsafe-eval' 'unsafe-inline';
      style-src 'self' 'unsafe-inline';
      connect-src 'self' https://api.erdo.ai;
      img-src 'self' data: blob:;
    `.replace(/\n/g, ''),
  },
];

module.exports = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: securityHeaders,
      },
    ];
  },
};
```

### Nginx Configuration

```nginx
add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://api.erdo.ai; script-src 'self'; style-src 'self' 'unsafe-inline';" always;
```

### Meta Tag (Fallback)

If you can't configure server headers, use a meta tag:

```html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; connect-src 'self' https://api.erdo.ai;"
/>
```

<Note>
If you're [proxying Erdo API requests through your own backend](#proxying-through-your-backend), you don't need to add `api.erdo.ai` to your CSPâ€”just ensure your proxy endpoint is allowed.
</Note>
