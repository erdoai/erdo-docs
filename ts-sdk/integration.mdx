---
title: "Integration Patterns"
description: "Common patterns for integrating Erdo into your applications"
---

# Integration Patterns

This guide covers common patterns for integrating Erdo into different application architectures.

## Next.js App Router

### Server Component

Fetch data on the server:

```tsx
// app/analysis/page.tsx
import { ErdoClient } from '@erdo/server';

export default async function AnalysisPage() {
  const client = new ErdoClient({
    authToken: process.env.ERDO_API_KEY,
  });

  const result = await client.invoke('data-analyst', {
    messages: [{ role: 'user', content: 'Generate a summary report' }],
  });

  return (
    <div>
      {result.result?.output?.content?.map((item, i) => (
        <div key={i}>{JSON.stringify(item)}</div>
      ))}
    </div>
  );
}
```

### Client Component with Streaming

```tsx
// app/chat/page.tsx
'use client';

import { ErdoProvider, useInvocation, Content } from '@erdo/ui';
import { ErdoClient } from '@erdo/server';
import { useState } from 'react';

const client = new ErdoClient({
  authToken: process.env.NEXT_PUBLIC_ERDO_API_KEY,
});

export default function ChatPage() {
  return (
    <ErdoProvider config={{ baseUrl: 'https://api.erdo.ai', client }}>
      <Chat />
    </ErdoProvider>
  );
}

function Chat() {
  const [query, setQuery] = useState('');
  const { result, isStreaming, invoke } = useInvocation();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await invoke('data-analyst', {
      messages: [{ role: 'user', content: query }],
    });
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Ask a question..."
        />
        <button disabled={isStreaming}>
          {isStreaming ? 'Analyzing...' : 'Send'}
        </button>
      </form>

      {result?.result?.output?.content?.map((item, i) => (
        <Content key={i} item={item} />
      ))}
    </div>
  );
}
```

## Vercel AI SDK

Use Erdo as a tool in your AI chat application:

```tsx
// app/api/chat/route.ts
import { openai } from '@ai-sdk/openai';
import { streamText, tool } from 'ai';
import { z } from 'zod';
import { ErdoClient } from '@erdo/server';

const erdoClient = new ErdoClient({
  authToken: process.env.ERDO_API_KEY,
});

export async function POST(req: Request) {
  const { messages } = await req.json();

  const result = streamText({
    model: openai('gpt-4'),
    messages,
    tools: {
      analyzeData: tool({
        description: 'Analyze data and create visualizations using Erdo',
        parameters: z.object({
          query: z.string().describe('The data analysis question'),
        }),
        execute: async ({ query }) => {
          const result = await erdoClient.invoke('data-analyst', {
            messages: [{ role: 'user', content: query }],
          });
          return result;
        },
      }),
    },
  });

  return result.toDataStreamResponse();
}
```

### Rendering Tool Results

```tsx
// components/chat.tsx
'use client';

import { useChat } from 'ai/react';
import { Content } from '@erdo/ui';

export function Chat() {
  const { messages, input, handleInputChange, handleSubmit } = useChat();

  return (
    <div>
      {messages.map((m) => (
        <div key={m.id}>
          {m.role === 'user' ? 'User: ' : 'AI: '}
          {m.content}

          {/* Render Erdo tool results */}
          {m.toolInvocations?.map((tool, i) => {
            if (tool.toolName === 'analyzeData' && tool.result) {
              return (
                <div key={i}>
                  {tool.result.result?.output?.content?.map((item, j) => (
                    <Content key={j} item={item} />
                  ))}
                </div>
              );
            }
          })}
        </div>
      ))}

      <form onSubmit={handleSubmit}>
        <input value={input} onChange={handleInputChange} />
        <button type="submit">Send</button>
      </form>
    </div>
  );
}
```

## Express.js / Node.js

### REST API Endpoint

```typescript
// server.ts
import express from 'express';
import { ErdoClient } from '@erdo/server';

const app = express();
const client = new ErdoClient({
  authToken: process.env.ERDO_API_KEY,
});

app.use(express.json());

app.post('/api/analyze', async (req, res) => {
  const { query } = req.body;

  try {
    const result = await client.invoke('data-analyst', {
      messages: [{ role: 'user', content: query }],
    });
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: 'Analysis failed' });
  }
});

app.listen(3000);
```

### SSE Streaming Endpoint

```typescript
app.get('/api/analyze/stream', async (req, res) => {
  const query = req.query.q as string;

  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  try {
    for await (const event of client.invokeStream('data-analyst', {
      messages: [{ role: 'user', content: query }],
    })) {
      res.write(`data: ${JSON.stringify(event)}\n\n`);
    }
  } catch (error) {
    res.write(`data: ${JSON.stringify({ type: 'error', payload: error })}\n\n`);
  }

  res.end();
});
```

## Proxying Through Your Backend

For B2B applications, you may want to proxy Erdo API requests through your own backend rather than having the client call `api.erdo.ai` directly. This approach:

- Keeps your Erdo API key server-side only
- Avoids CSP configuration for `api.erdo.ai`
- Allows you to add custom authentication, logging, or rate limiting

### Option 1: Custom Endpoint

Point the SDK to your own API endpoint:

```typescript
// Server-side client
const client = new ErdoClient({
  authToken: process.env.ERDO_API_KEY,
  endpoint: 'https://your-backend.com/api/erdo',  // Your proxy
});

// Or via environment variable
// ERDO_ENDPOINT=https://your-backend.com/api/erdo
```

```tsx
// UI provider
<ErdoProvider
  config={{
    baseUrl: 'https://your-backend.com/api/erdo',
    authToken: userSessionToken,  // Your app's auth, not Erdo key
  }}
>
  {children}
</ErdoProvider>
```

Your backend then forwards requests to `api.erdo.ai`:

```typescript
// Your backend proxy endpoint
app.all('/api/erdo/*', async (req, res) => {
  const erdoPath = req.path.replace('/api/erdo', '');
  const response = await fetch(`https://api.erdo.ai${erdoPath}`, {
    method: req.method,
    headers: {
      'Authorization': `Bearer ${process.env.ERDO_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined,
  });

  // Forward the response (including SSE streams)
  res.status(response.status);
  response.body?.pipeTo(new WritableStream({
    write: (chunk) => res.write(chunk),
    close: () => res.end(),
  }));
});
```

### Option 2: Custom Data Fetcher

For more control over how data is fetched (e.g., using a typed API client), provide a custom `dataFetcher`:

```tsx
// lib/erdo-fetcher.ts - Create ONCE outside components
import { DataFetcher } from '@erdo/ui';

export const erdoDataFetcher: DataFetcher = {
  fetchDatasetContents: async (slug, invocationId) => {
    // Use your own API client
    const res = await fetch(`/api/datasets/${slug}?invocationId=${invocationId}`);
    return res.json();
  },
};
```

```tsx
// providers/erdo-provider.tsx
import { ErdoProvider } from '@erdo/ui';
import { erdoDataFetcher } from '../lib/erdo-fetcher';

export function AppProvider({ children }) {
  return (
    <ErdoProvider
      config={{
        baseUrl: '/api',
        dataFetcher: erdoDataFetcher,
      }}
    >
      {children}
    </ErdoProvider>
  );
}
```

<Note>
When using a custom `dataFetcher`, the `baseUrl` is still used by the `useInvocation` hook. Only `fetchDatasetContents` calls are overridden.
</Note>

## Error Handling

### Client-Side Error Boundary

```tsx
import { ErrorBoundary } from '@erdo/ui';

function App() {
  return (
    <ErrorBoundary fallback={<div>Something went wrong</div>}>
      <ChatInterface />
    </ErrorBoundary>
  );
}
```

### Hook-Level Error Handling

```tsx
const { error, invoke } = useInvocation({
  onError: (err) => {
    // Log to error tracking service
    console.error('Invocation failed:', err);
    toast.error('Analysis failed. Please try again.');
  },
});
```

## Authentication

### API Key (Server-Side)

Store your API key securely in environment variables:

```bash
# .env
ERDO_API_KEY=your-api-key
```

```typescript
// Only use on server-side
const client = new ErdoClient({
  authToken: process.env.ERDO_API_KEY,
});
```

### Client-Side (Public Key)

For client-side usage, use a public/restricted API key:

```typescript
// Safe for client-side
const client = new ErdoClient({
  authToken: process.env.NEXT_PUBLIC_ERDO_API_KEY,
});
```

<Warning>
Never expose your full API key in client-side code. Use a restricted key with appropriate permissions.
</Warning>

## Content Security Policy (CSP)

If your application uses Content Security Policy headers, you'll need to allow connections to the Erdo API for the UI components to fetch data.

### Required Directives

Add the following to your CSP configuration:

```
connect-src 'self' https://api.erdo.ai;
```

This allows the `@erdo/ui` components to:
- Fetch dataset contents for rendering charts and tables
- Stream agent invocation results in real-time

### Next.js Configuration

```javascript
// next.config.js
const securityHeaders = [
  {
    key: 'Content-Security-Policy',
    value: `
      default-src 'self';
      script-src 'self' 'unsafe-eval' 'unsafe-inline';
      style-src 'self' 'unsafe-inline';
      connect-src 'self' https://api.erdo.ai;
      img-src 'self' data: blob:;
    `.replace(/\n/g, ''),
  },
];

module.exports = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: securityHeaders,
      },
    ];
  },
};
```

### Nginx Configuration

```nginx
add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://api.erdo.ai; script-src 'self'; style-src 'self' 'unsafe-inline';" always;
```

### Meta Tag (Fallback)

If you can't configure server headers, use a meta tag:

```html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; connect-src 'self' https://api.erdo.ai;"
/>
```

<Note>
If you're [proxying Erdo API requests through your own backend](#proxying-through-your-backend), you don't need to add `api.erdo.ai` to your CSPâ€”just ensure your proxy endpoint is allowed.
</Note>
