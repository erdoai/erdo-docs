---
title: "Result Handlers"
description: "Handle step outcomes with conditional logic using @step.when() decorators and step.on() methods"
---

# Result Handlers

Result handlers define how agents respond to step outcomes, enabling sophisticated conditional logic and workflow control. You can use `@step.when()` decorators and `step.on()` methods for clean, readable result handling.

## What are Result Handlers?

Result handlers allow you to:

- **React to step outcomes** (success, failure, specific conditions)
- **Implement conditional logic** based on step results
- **Chain actions** based on different scenarios
- **Handle errors gracefully** with fallback strategies
- **Control workflow flow** dynamically

<CardGroup cols={2}>
  <Card title="Decorator Handlers" icon="at">
    Use @step.when() decorators for clean, readable handlers
  </Card>
  <Card title="Direct Handlers" icon="link">
    Use step.on() for direct action chaining
  </Card>
  <Card title="Conditional Logic" icon="code-branch">
    Complex conditions with & (and), | (or), ~ (not) operators
  </Card>
  <Card title="Error Recovery" icon="refresh">
    Implement sophisticated error handling and recovery
  </Card>
</CardGroup>

## Handler Methods

### Decorator-Based Handlers with @step.when()

The most readable way to handle step outcomes:

```python
from erdo import Agent
from erdo.actions import llm, memory, utils
from erdo.conditions import IsSuccess, IsError, GreaterThan, TextContains

agent = Agent(name="analysis_agent")

analysis_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Analyze this data: {{input_data}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "confidence": {"type": "number"},
                    "insights": {"type": "array"},
                    "risk_level": {"type": "string"}
                }
            }
        }
    )
)

@analysis_step.when(IsSuccess() & GreaterThan("confidence", "0.8"))
def handle_high_confidence(result):
    """Store high-confidence analysis results."""
    return memory.store(memory={
        "content": result.output.insights,
        "description": "High-confidence analysis results",
        "type": "analysis_result",
        "tags": ["analysis", "high-confidence"],
        "extra": {"confidence": result.output.confidence}
    })

@analysis_step.when(IsSuccess() & GreaterThan("confidence", "0.5") & GreaterThan("0.8", "confidence"))
def handle_moderate_confidence(result):
    """Request review for moderate confidence results."""
    return utils.send_status(
        status="review_needed",
        message="Analysis completed with moderate confidence. Human review recommended.",
        data=result.output
    )

@analysis_step.when(IsSuccess() & GreaterThan("0.5", "confidence"))
def handle_low_confidence(result):
    """Flag low confidence results."""
    return utils.send_status(
        status="low_confidence",
        message="Analysis completed but confidence is very low. Results may be unreliable.",
        data=result.output
    )

@analysis_step.when(IsError())
def handle_analysis_error(error):
    """Handle analysis failures."""
    return utils.send_status(
        status="failed",
        message=f"Analysis failed: {error.message}",
        error=error.details
    )
```

### Direct Handlers with step.on()

For direct action chaining:

```python
# Single action handler
analysis_step.on(
    IsSuccess() & GreaterThan("confidence", "0.9"),
    utils.send_status(status="excellent", message="Excellent analysis results")
)

# Multiple action handler
analysis_step.on(
    IsSuccess() & GreaterThan("confidence", "0.9"),
    utils.send_status(status="excellent", message="Excellent analysis results"),
    memory.store(memory={
        "content": "{{analysis_step.output.insights}}",
        "type": "excellent_analysis"
    }),
    utils.echo(message="Analysis stored successfully")
)

# Handle critical risk levels
analysis_step.on(
    IsSuccess() & TextContains("risk_level", "critical"),
    utils.send_status(
        status="critical_alert",
        message="CRITICAL RISK DETECTED - Immediate attention required",
        priority="urgent"
    )
)

# Simple error handling
analysis_step.on(
    IsError(),
    utils.send_status(status="failed", message="Analysis failed, retrying...")
)
```

## Conditional Logic

### Basic Conditions

```python
from erdo.conditions import (
    IsSuccess, IsError, GreaterThan, LessThan,
    TextContains, TextEquals, Not
)

# Success conditions
@step.when(IsSuccess())
def handle_success(result):
    return memory.store(memory={"content": result.output.data})

# Error conditions
@step.when(IsError())
def handle_error(error):
    return utils.send_status(status="failed", message=error.message)

# Numeric comparisons
@step.when(IsSuccess() & GreaterThan("score", "0.8"))
def handle_high_score(result):
    return utils.send_status(status="high_score", message="Excellent results!")

@step.when(IsSuccess() & LessThan("score", "0.3"))
def handle_low_score(result):
    return utils.send_status(status="low_score", message="Results need improvement")

# Text conditions
@step.when(IsSuccess() & TextContains("category", "urgent"))
def handle_urgent(result):
    return utils.send_status(status="urgent", priority="high")

@step.when(IsSuccess() & TextEquals("status", "completed"))
def handle_completed(result):
    return memory.store(memory={"content": "Task completed successfully"})
```

### Complex Conditions

Combine conditions with logical operators:

```python
# AND operator (&)
@step.when(IsSuccess() & GreaterThan("confidence", "0.8") & TextContains("category", "important"))
def handle_high_confidence_important(result):
    return memory.store(memory={
        "content": result.output.analysis,
        "type": "high_priority_analysis"
    })

# OR operator (|)
@step.when(
    IsSuccess() & (
        TextContains("risk_level", "high") |
        TextContains("risk_level", "critical")
    )
)
def handle_high_risk(result):
    return utils.send_status(
        status="high_risk_alert",
        message="High risk detected - immediate attention required"
    )

# NOT operator (~)
@step.when(IsSuccess() & ~TextContains("status", "completed"))
def handle_incomplete(result):
    return utils.send_status(
        status="incomplete",
        message="Process not completed - may need retry"
    )

# Complex nested conditions
@step.when(
    IsSuccess() &
    (GreaterThan("confidence", "0.7") | TextEquals("priority", "high")) &
    ~TextContains("errors", "critical")
)
def handle_complex_success(result):
    return memory.store(memory={
        "content": result.output.data,
        "type": "validated_result"
    })
```

## Error Handling Patterns

### Retry Logic

```python
from erdo.conditions import IsError, LessThan

process_step = agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "main_process.py",
            "content": "main_processing_logic({{input_data}})"
        }]
    )
)

@process_step.when(IsError() & LessThan("retry_count", "3"))
def retry_with_backoff(error):
    """Retry processing with exponential backoff."""
    return codeexec.execute(
        code_files=[{
            "filename": "retry_process.py",
            "content": """
import time
import random

# Exponential backoff
retry_count = int('{{retry_count}}' or '0')
delay = (2 ** retry_count) + random.uniform(0, 1)
time.sleep(delay)

# Retry the operation
retry_processing_logic({{input_data}})
"""
        }]
    )

@process_step.when(IsError() & GreaterThan("retry_count", "2"))
def escalate_persistent_failure(error):
    """Escalate after max retries exceeded."""
    return utils.send_status(
        status="escalated",
        message=f"Processing failed after 3 attempts: {error.message}",
        priority="critical",
        error_details=error.details
    )
```

### Graceful Degradation

```python
primary_analysis = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Perform detailed analysis: {{complex_data}}"
    )
)

@primary_analysis.when(IsError())
def fallback_to_simpler_analysis(error):
    """Use simpler analysis when primary fails."""
    return llm.message(
        model="gpt-4",
        query="Perform basic analysis: {{simplified_data}}",
        system_prompt="Provide a basic summary analysis"
    )

secondary_analysis = agent.step(
    llm.message(
        model="gpt-4",
        query="Basic analysis: {{input_data}}"
    )
)

@secondary_analysis.when(IsError())
def final_fallback(error):
    """Final fallback to rule-based analysis."""
    return codeexec.execute(
        code_files=[{
            "filename": "rule_based_analysis.py",
            "content": "perform_rule_based_analysis({{input_data}})"
        }]
    )
```

### Error Recovery with Context

```python
data_processing = agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "data_processor.py",
            "content": "process_complex_data({{input_data}})"
        }]
    )
)

@data_processing.when(IsError() & TextContains("error_type", "memory"))
def handle_memory_error(error):
    """Handle memory-related errors by processing in chunks."""
    return codeexec.execute(
        code_files=[{
            "filename": "chunked_processor.py",
            "content": """
# Process data in smaller chunks to avoid memory issues
import pandas as pd

data = pd.read_csv('{{input_data}}')
chunk_size = 1000
results = []

for chunk in pd.read_csv('{{input_data}}', chunksize=chunk_size):
    chunk_result = process_chunk(chunk)
    results.append(chunk_result)

final_result = combine_results(results)
print(json.dumps(final_result))
"""
        }]
    )

@data_processing.when(IsError() & TextContains("error_type", "format"))
def handle_format_error(error):
    """Handle data format errors with preprocessing."""
    return codeexec.execute(
        code_files=[{
            "filename": "format_fixer.py",
            "content": """
# Fix common data format issues
import pandas as pd
import numpy as np

try:
    # Attempt to fix common format issues
    data = pd.read_csv('{{input_data}}', encoding='utf-8')
    data = data.replace([np.inf, -np.inf], np.nan)
    data = data.dropna()

    # Process the cleaned data
    result = process_clean_data(data)
    print(json.dumps(result))
except Exception as e:
    print(f"Format fixing failed: {str(e)}")
"""
        }]
    )
```

## Advanced Result Handling

### Multi-Step Result Chains

```python
initial_analysis = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Initial analysis: {{input_data}}"
    )
)

@initial_analysis.when(IsSuccess() & GreaterThan("complexity", "0.8"))
def trigger_detailed_analysis(result):
    """Trigger detailed analysis for complex cases."""
    return llm.message(
        model="claude-sonnet-4",
        query="Detailed analysis needed for: {{initial_analysis.output.findings}}",
        system_prompt="You are a senior analyst. Provide comprehensive analysis."
    )

@initial_analysis.when(IsSuccess() & LessThan("complexity", "0.3"))
def handle_simple_case(result):
    """Handle simple cases with basic processing."""
    return utils.send_status(
        status="completed",
        message="Simple case processed successfully",
        result=result.output.summary
    )

@initial_analysis.when(IsSuccess() & GreaterThan("confidence", "0.9"))
def auto_approve_high_confidence(result):
    """Auto-approve high-confidence results."""
    return memory.store(memory={
        "content": result.output.analysis,
        "type": "auto_approved",
        "approval_reason": "high_confidence_auto_approval"
    })
```

### Conditional Workflow Branching

```python
risk_assessment = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Assess risk level: {{transaction_data}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "risk_score": {"type": "number"},
                    "risk_category": {"type": "string"},
                    "flags": {"type": "array"}
                }
            }
        }
    )
)

# Low risk - auto-approve
@risk_assessment.when(IsSuccess() & LessThan("risk_score", "0.3"))
def auto_approve_low_risk(result):
    """Auto-approve low-risk transactions."""
    return utils.send_status(
        status="approved",
        message="Transaction auto-approved - low risk",
        risk_score=result.output.risk_score
    )

# Medium risk - flag for review
@risk_assessment.when(
    IsSuccess() &
    GreaterThan("risk_score", "0.3") &
    LessThan("risk_score", "0.7")
)
def flag_for_review(result):
    """Flag medium-risk transactions for human review."""
    return utils.send_status(
        status="pending_review",
        message="Transaction flagged for human review",
        risk_details=result.output.flags
    )

# High risk - immediate escalation
@risk_assessment.when(IsSuccess() & GreaterThan("risk_score", "0.7"))
def escalate_high_risk(result):
    """Immediately escalate high-risk transactions."""
    return utils.send_status(
        status="escalated",
        message="HIGH RISK TRANSACTION - Immediate review required",
        priority="urgent",
        risk_score=result.output.risk_score,
        flags=result.output.flags
    )
```

### Dynamic Handler Selection

```python
content_analysis = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Analyze content type and quality: {{content}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "content_type": {"type": "string"},
                    "quality_score": {"type": "number"},
                    "language": {"type": "string"},
                    "sentiment": {"type": "string"}
                }
            }
        }
    )
)

# Handle different content types
@content_analysis.when(IsSuccess() & TextEquals("content_type", "technical"))
def handle_technical_content(result):
    """Process technical content with specialized analysis."""
    return llm.message(
        model="claude-sonnet-4",
        query="Technical analysis: {{content}}",
        system_prompt="You are a technical expert. Analyze for accuracy and completeness."
    )

@content_analysis.when(IsSuccess() & TextEquals("content_type", "creative"))
def handle_creative_content(result):
    """Process creative content with different criteria."""
    return llm.message(
        model="claude-sonnet-4",
        query="Creative analysis: {{content}}",
        system_prompt="You are a creative expert. Analyze for originality and impact."
    )

@content_analysis.when(IsSuccess() & TextEquals("content_type", "legal"))
def handle_legal_content(result):
    """Process legal content with compliance focus."""
    return llm.message(
        model="claude-sonnet-4",
        query="Legal compliance analysis: {{content}}",
        system_prompt="You are a legal expert. Analyze for compliance and risk."
    )

# Quality-based routing
@content_analysis.when(IsSuccess() & LessThan("quality_score", "0.4"))
def handle_low_quality(result):
    """Handle low-quality content with improvement suggestions."""
    return llm.message(
        model="claude-sonnet-4",
        query="Improve this content: {{content}}",
        system_prompt="Provide specific suggestions to improve content quality."
    )
```

## Best Practices

### Handler Organization

```python
# Group related handlers together
analysis_step = agent.step(llm.message(...))

# Success handlers
@analysis_step.when(IsSuccess() & GreaterThan("confidence", "0.8"))
def store_high_confidence_results(result):
    return memory.store(memory={...})

@analysis_step.when(IsSuccess() & LessThan("confidence", "0.5"))
def flag_low_confidence_results(result):
    return utils.send_status(status="review_needed", ...)

# Error handlers
@analysis_step.when(IsError())
def handle_general_error(error):
    return utils.send_status(status="failed", ...)
```

### Condition Specificity

```python
# Be specific with conditions to avoid conflicts
@step.when(IsSuccess() & GreaterThan("score", "0.9"))
def handle_excellent(result): pass

@step.when(IsSuccess() & GreaterThan("score", "0.7") & LessThan("score", "0.9"))
def handle_good(result): pass

@step.when(IsSuccess() & LessThan("score", "0.7"))
def handle_needs_improvement(result): pass
```

### Error Context Preservation

```python
@step.when(IsError())
def preserve_error_context(error):
    """Preserve error context for debugging."""
    return memory.store(memory={
        "content": f"Error in step: {error.message}",
        "type": "error_log",
        "tags": ["error", "{{step_name}}", "{{timestamp}}"],
        "extra": {
            "error_type": error.type,
            "error_details": error.details,
            "input_data": "{{input_data}}",
            "step_config": "{{step_config}}"
        }
    })
```

### Performance Considerations

```python
# Use direct handlers for simple actions
step.on(
    IsSuccess(),
    utils.send_status(status="completed", message="Processing finished")
)

# Use decorator handlers for complex logic
@step.when(IsSuccess() & complex_condition)
def handle_complex_case(result):
    # Complex processing logic here
    processed_data = complex_processing(result.output)
    return memory.store(memory={"content": processed_data})
```

## Testing Result Handlers

### Handler Validation

```python
validation_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Validate input: {{test_input}}"
    )
)

@validation_step.when(IsSuccess())
def test_success_handler(result):
    """Test handler for successful validation."""
    return utils.echo(data={
        "test_result": "success_handler_triggered",
        "output": result.output
    })

@validation_step.when(IsError())
def test_error_handler(error):
    """Test handler for validation errors."""
    return utils.echo(data={
        "test_result": "error_handler_triggered",
        "error": error.message
    })
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Conditions" icon="code-branch" href="/concepts/conditions">
    Learn about available condition types and operators
  </Card>
  <Card title="Actions" icon="bolt" href="/concepts/actions">
    Explore actions you can use in result handlers
  </Card>
  <Card title="Examples" icon="lightbulb" href="/examples/business-automation">
    See result handlers in complete workflows
  </Card>
  <Card title="SDK Reference" icon="code" href="/sdk/overview">
    Complete SDK documentation and reference
  </Card>
</CardGroup>
