---
title: "Agents"
description: "Understanding agents - the core containers for AI workflows and automation"
---

# Agents

Agents are the foundational containers for AI workflows in Erdo. They encapsulate the logic, steps, and configuration needed to automate complex tasks using AI models and tools.

## What is an Agent?

An agent represents a complete AI workflow that can:

- Execute multiple steps in sequence or parallel
- Make decisions based on data and conditions
- Use external tools and services
- Handle errors and retry logic
- Store and retrieve knowledge

<CardGroup cols={2}>
  <Card title="Single-Purpose Agents" icon="target">
    Focused on one specific task like data analysis or email processing
  </Card>
  <Card title="Multi-Purpose Agents" icon="layers">
    Handle complex workflows with multiple decision points and actions
  </Card>
  <Card title="Orchestrator Agents" icon="sitemap">
    Coordinate other agents and manage complex pipelines
  </Card>
  <Card title="Interactive Agents" icon="comments">
    Respond to user inputs and maintain conversation context
  </Card>
</CardGroup>

## Agent Structure

### Basic Agent Definition

```python
from erdo import Agent

my_agent = Agent(
    name="data_analyzer",
    description="Analyzes data and generates insights",
    visibility="public"  # or "private"
)
```

### Agent Properties

<Tabs>
  <Tab title="Core Properties">
    ```python agent = Agent( name="unique_agent_name", # Required: Unique
    identifier description="What this agent does", # Required: Clear description
    visibility="public", # public, private, or organization version="1.0.0", #
    Semantic versioning tags=["analysis", "automation"], # Categorization tags
    timeout=300 # Maximum execution time (seconds) ) ```
  </Tab>
  <Tab title="Advanced Configuration">
    ```python agent = Agent( name="advanced_agent", description="Advanced agent
    with custom configuration", visibility="organization",
    running_message="Processing your request...", finished_message="Analysis
    complete!", retry_attempts=3, tags=["data", "analysis", "automation"] ) ```
  </Tab>
</Tabs>

## Agent Types and Patterns

### Data Processing Agents

Agents focused on analyzing and transforming data:

```python
from erdo import Agent
from erdo.actions import llm, codeexec, memory
from erdo.conditions import IsSuccess, GreaterThan

data_agent = Agent(
    name="sales_data_analyzer",
    description="Analyzes sales data and generates business insights"
)

analyze_step = data_agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Analyze sales data: {{data}}",
        system_prompt="You are a business analyst expert"
    )
)

calculate_step = data_agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "metrics.py",
            "content": "calculate_sales_metrics({{analyze_step.output.insights}})"
        }]
    ),
    depends_on=analyze_step
)

@calculate_step.when(IsSuccess())
def store_results(result):
    return memory.store(memory={
        "content": result.output.metrics,
        "type": "sales_analysis"
    })
```

### Research Agents

Agents that gather and synthesize information:

```python
from erdo.actions import websearch, webparser

research_agent = Agent(
    name="market_researcher",
    description="Conducts market research and competitive analysis"
)

search_step = research_agent.step(
    websearch.search(
        query="{{topic}} market analysis {{industry}}",
        language="en",
        country="us"
    )
)

parse_step = research_agent.step(
    webparser.parse(
        url="{{target_url}}",
        selectors=["h1", "p", ".content"],
        extract_links=True
    )
)

synthesis_step = research_agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Synthesize research findings: {{search_step.output.results}}",
        system_prompt="You are a market research analyst"
    ),
    depends_on=[search_step, parse_step]
)
```

### Automation Agents

Agents that automate business processes:

```python
from erdo.conditions import TextEquals, IsSuccess, Not

automation_agent = Agent(
    name="email_processor",
    description="Automates email categorization and response"
)

classify_step = automation_agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Classify this email: {{email_content}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "category": {"type": "string"},
                    "priority": {"type": "string"},
                    "requires_response": {"type": "boolean"}
                }
            }
        }
    )
)

@classify_step.when(IsSuccess() & TextEquals("requires_response", "true"))
def generate_response(result):
    return llm.message(
        model="claude-sonnet-4",
        query="Generate response for {{category}} email: {{email_content}}"
    )

classify_step.on(
    IsSuccess() & TextEquals("priority", "urgent"),
    utils.send_status(
        status="urgent_email",
        message="Urgent email detected - immediate attention required"
    )
)
```

### Conversational Agents

Agents that maintain context across interactions:

```python
from erdo.actions import memory

chat_agent = Agent(
    name="customer_support",
    description="Provides intelligent customer support with context awareness"
)

context_step = chat_agent.step(
    memory.search(
        query="{{user_message}} {{customer_id}}",
        limit=5,
        organization_scope="specific"
    )
)

response_step = chat_agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="{{user_message}}",
        context="{{context_step.output.memories}}",
        system_prompt="You are a helpful customer support agent"
    ),
    depends_on=context_step
)

@response_step.when(IsSuccess())
def store_conversation(result):
    return memory.store(memory={
        "content": f"User: {{user_message}}\nAgent: {result.output.response}",
        "type": "conversation",
        "tags": ["support", "{{customer_id}}"]
    })
```

## Agent Composition

### Modular Design

Break complex workflows into focused agents:

```python
# Data collection agent
collector = Agent(name="data_collector")
collect_step = collector.step(websearch.search(query="{{topic}}"))

# Analysis agent
analyzer = Agent(name="data_analyzer")
analyze_step = analyzer.step(
    llm.message(query="Analyze: {{collected_data}}")
)

# Reporting agent
reporter = Agent(name="report_generator")
report_step = reporter.step(
    llm.message(query="Generate report: {{analysis_results}}")
)
```

### Agent Orchestration

Coordinate multiple agents for complex workflows:

```python
orchestrator = Agent(
    name="research_orchestrator",
    description="Coordinates research workflow across multiple agents"
)

# Trigger data collection
trigger_collection = orchestrator.step(
    utils.trigger_agent(
        agent_name="data_collector",
        parameters={"topic": "{{research_topic}}"}
    )
)

# Trigger analysis after collection
trigger_analysis = orchestrator.step(
    utils.trigger_agent(
        agent_name="data_analyzer",
        parameters={"data": "{{trigger_collection.output.results}}"}
    ),
    depends_on=trigger_collection
)

# Generate final report
final_report = orchestrator.step(
    utils.trigger_agent(
        agent_name="report_generator",
        parameters={"analysis": "{{trigger_analysis.output.insights}}"}
    ),
    depends_on=trigger_analysis
)
```

## Best Practices

### Agent Design Principles

1. **Single Responsibility**: Each agent should have a clear, focused purpose
2. **Composability**: Design agents to work together in larger workflows
3. **Error Handling**: Always include error handling for robust operation
4. **State Management**: Use memory effectively for context and persistence

### Naming Conventions

```python
# Good: Descriptive, action-oriented names
email_processor = Agent(name="email_processor")
data_analyzer = Agent(name="sales_data_analyzer")
content_generator = Agent(name="marketing_content_generator")

# Avoid: Generic or unclear names
agent1 = Agent(name="agent1")
helper = Agent(name="helper")
processor = Agent(name="processor")
```

### Configuration Management

```python
# Use environment-specific configurations
production_agent = Agent(
    name="production_analyzer",
    description="Production data analysis agent",
    visibility="organization",
    timeout=600,
    retry_attempts=3
)

development_agent = Agent(
    name="dev_analyzer",
    description="Development testing agent",
    visibility="private",
    timeout=120,
    retry_attempts=1
)
```

### Testing and Validation

```python
# Include validation steps
validator_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Validate this analysis: {{analysis_result}}",
        system_prompt="You are a data validation expert"
    )
)

@validator_step.when(IsSuccess() & TextEquals("valid", "false"))
def handle_invalid_analysis(result):
    return utils.send_status(
        status="validation_failed",
        message="Analysis failed validation - review required"
    )
```

## Agent Lifecycle

### Development Workflow

1. **Design**: Define agent purpose and workflow
2. **Implement**: Create steps and result handlers
3. **Test**: Validate locally with sample data
4. **Deploy**: Sync to production environment
5. **Monitor**: Track performance and errors
6. **Iterate**: Improve based on feedback

### Deployment Considerations

- **Resource Requirements**: Consider memory and compute needs
- **Scaling**: Design for expected load and concurrency
- **Security**: Implement appropriate access controls
- **Monitoring**: Set up alerting for failures and performance issues

## Next Steps

<CardGroup cols={2}>
  <Card title="Steps" icon="list-check" href="/concepts/steps">
    Learn about creating and managing workflow steps
  </Card>
  <Card title="Actions" icon="bolt" href="/concepts/actions">
    Explore the available action types and their uses
  </Card>
  <Card title="Result Handlers" icon="wrench" href="/concepts/result-handlers">
    Master conditional logic and error handling
  </Card>
  <Card title="Examples" icon="lightbulb" href="/examples/business-automation">
    See complete agent implementations
  </Card>
</CardGroup>
