---
title: "Steps"
description: "Understanding steps - the building blocks of agent workflows"
---

# Steps

Steps are the individual building blocks that make up agent workflows. Each step represents a single action or operation that contributes to the overall goal of the agent.

## What is a Step?

A step defines:

- **What action to perform** (LLM call, code execution, memory operation, etc.)
- **When to execute** (dependencies, conditions)
- **How to handle results** (success, error, retry logic)
- **What data to use** (inputs, parameters, previous step outputs)

<CardGroup cols={2}>
  <Card title="Action Steps" icon="play">
    Perform specific actions like LLM calls or code execution
  </Card>
  <Card title="Control Steps" icon="route">
    Manage workflow flow and conditional logic
  </Card>
  <Card title="Data Steps" icon="database">
    Handle data transformation and storage operations
  </Card>
  <Card title="Integration Steps" icon="plug">
    Interface with external tools and services
  </Card>
</CardGroup>

## Step Structure

### Basic Step Definition

```python
from erdo import Step
from erdo.actions import llm

basic_step = Step(
    agent=my_agent,
    key="analyze_data",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="{{user_input}}"
    )
)
```

### Step Properties

<Tabs>
  <Tab title="Core Properties">
    ```python
    step = Step(
        agent=my_agent,                    # Required: Parent agent
        key="unique_step_name",            # Required: Unique identifier
        actiontype=llm.message(...),       # Required: Action to perform
        depends_on=[previous_step],        # Dependencies
        user_output_visibility="visible",  # visible, hidden
        bot_output_visibility="visible",   # visible, hidden
        running_message="Processing...",   # Status during execution
        finished_message="Complete!"      # Status when done
    )
    ```
  </Tab>
  <Tab title="Advanced Properties">
    ```python
    advanced_step = Step(
        agent=my_agent,
        key="advanced_process",
        actiontype=codeexec.execute(...),
        depends_on=[step1, step2],
        execution_mode=ExecutionMode(
            mode="all",
            if_condition=IsSuccess()
        ),
        timeout=300,                       # Step timeout in seconds
        retry_config={
            "max_attempts": 3,
            "backoff_factor": 2,
            "retry_on": ["timeout", "rate_limit"]
        }
    )
    ```
  </Tab>
</Tabs>

## Step Dependencies

### Sequential Execution

Steps can depend on previous steps for ordered execution:

```python
# Step 1: Data collection
collect_step = Step(
    agent=agent,
    key="collect",
    actiontype=websearch.search(query="{{topic}}")
)

# Step 2: Analysis (depends on collection)
analyze_step = Step(
    agent=agent,
    key="analyze",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="Analyze this data: {{steps.collect.results}}"
    ),
    depends_on=[collect_step]
)

# Step 3: Report (depends on analysis)
report_step = Step(
    agent=agent,
    key="report",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="Create report from: {{steps.analyze.insights}}"
    ),
    depends_on=[analyze_step]
)
```

### Parallel Execution

Steps without dependencies can run in parallel:

```python
# These steps can run simultaneously
process_sales = Step(
    agent=agent,
    key="process_sales",
    actiontype=codeexec.execute(code="process_sales_data({{sales_data}})")
)

process_marketing = Step(
    agent=agent,
    key="process_marketing",
    actiontype=codeexec.execute(code="process_marketing_data({{marketing_data}})")
)

process_finance = Step(
    agent=agent,
    key="process_finance",
    actiontype=codeexec.execute(code="process_finance_data({{finance_data}})")
)

# Combine results after parallel processing
combine_step = Step(
    agent=agent,
    key="combine",
    actiontype=codeexec.execute(
        code="combine_results({{steps.process_sales.output}}, {{steps.process_marketing.output}}, {{steps.process_finance.output}})"
    ),
    depends_on=[process_sales, process_marketing, process_finance]
)
```

### Complex Dependencies

Handle complex dependency patterns:

```python
# Multiple dependency patterns
validation_step = Step(
    agent=agent,
    key="validate",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="Validate results from multiple sources"
    ),
    depends_on=[
        data_collection_step,
        external_api_step,
        database_query_step
    ]
)
```

## Conditional Execution

### Execution Modes

Control when and how steps execute:

```python
from erdo import ExecutionMode
from erdo._generated.condition import IsSuccess, TextContains, GreaterThan

# Only execute if previous step succeeded
conditional_step = Step(
    agent=agent,
    key="conditional",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="{{conditional_query}}"
    ),
    execution_mode=ExecutionMode(
        mode="all",
        if_condition=IsSuccess(step="data_analysis")
    )
)

# Execute only for large datasets
large_data_step = Step(
    agent=agent,
    key="large_data_process",
    actiontype=codeexec.execute(
        code="advanced_processing({{data}})"
    ),
    execution_mode=ExecutionMode(
        mode="all",
        if_condition=GreaterThan(
            number="{{data_size}}",
            value="1000"
        )
    )
)

# Execute based on content analysis
content_specific_step = Step(
    agent=agent,
    key="content_specific",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="{{specialized_query}}"
    ),
    execution_mode=ExecutionMode(
        mode="all",
        if_condition=TextContains(
            text="{{content_type}}",
            value="technical"
        )
    )
)
```

### Iterative Execution

Process collections of data:

```python
# Process each item in a collection
iterative_step = Step(
    agent=agent,
    key="process_items",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="Process this item: {{item}}"
    ),
    execution_mode=ExecutionMode(
        mode="iterate_over",
        data="items_list"
    )
)

# Conditional iteration
filtered_iteration = Step(
    agent=agent,
    key="process_priority_items",
    actiontype=codeexec.execute(
        code="process_priority_item({{item}})"
    ),
    execution_mode=ExecutionMode(
        mode="iterate_over",
        data="all_items",
        if_condition=TextEquals(
            text="{{item.priority}}",
            value="high"
        )
    )
)
```

## Data Flow and Variables

### Accessing Step Outputs

Use outputs from previous steps in subsequent steps:

```python
# First step generates data
generation_step = Step(
    agent=agent,
    key="generate",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="Generate analysis plan for {{topic}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "schema": {
                    "type": "object",
                    "properties": {
                        "plan": {"type": "string"},
                        "steps": {"type": "array"},
                        "estimated_time": {"type": "number"}
                    }
                }
            }
        }
    )
)

# Second step uses generated data
execution_step = Step(
    agent=agent,
    key="execute",
    actiontype=codeexec.execute(
        code="""
# Use data from previous step
plan = {{steps.generate.plan}}
steps = {{steps.generate.steps}}
estimated_time = {{steps.generate.estimated_time}}

execute_plan(plan, steps)
"""
    ),
    depends_on=[generation_step]
)
```

### Variable Interpolation

Use template variables throughout your steps:

```python
dynamic_step = Step(
    agent=agent,
    key="dynamic",
    actiontype=llm.message(
        model="{{preferred_model}}",
        query="Analyze {{data_type}} data: {{input_data}}",
        system_prompt="You are a {{expert_type}} expert specializing in {{domain}}"
    )
)
```

### Complex Data Transformation

Transform and combine data from multiple sources:

```python
transformation_step = Step(
    agent=agent,
    key="transform",
    actiontype=codeexec.execute(
        code="""
# Combine data from multiple previous steps
raw_data = {{steps.collect.data}}
analysis_results = {{steps.analyze.results}}
external_data = {{steps.external_api.response}}

# Transform and combine
processed_data = transform_data(raw_data)
enriched_data = enrich_with_analysis(processed_data, analysis_results)
final_data = merge_external_data(enriched_data, external_data)

return {
    "processed_items": len(final_data),
    "data_quality": calculate_quality(final_data),
    "insights": extract_insights(final_data)
}
"""
    ),
    depends_on=[collect_step, analyze_step, external_api_step]
)
```

## Error Handling

### Result Handlers

Define how to handle different step outcomes:

```python
from erdo import ResultHandler
from erdo._generated.condition import IsError, IsSuccess, LessThan

# Main processing step
main_step = Step(
    agent=agent,
    key="main_process",
    actiontype=codeexec.execute(
        code="{{generated_code}}"
    )
)

# Success handler
success_handler = ResultHandler(
    step=main_step,
    type="final",
    if_conditions=IsSuccess(),
    result_handler_order=0
)

# Retry handler for errors
retry_handler = ResultHandler(
    step=main_step,
    type="intermediate",
    if_conditions=And(
        IsError(),
        LessThan(number="{{retry_count}}", value="3")
    ),
    result_handler_order=1
)

# Error recovery step
recovery_step = Step(
    result_handler=retry_handler,
    key="recovery",
    actiontype=utils.echo(
        data={
            "retry_count": "{{increment retry_count}}",
            "error": "{{error_message}}"
        }
    )
)
```

### Error Types and Recovery

Handle different types of errors appropriately:

```python
# Network error recovery
network_error_handler = ResultHandler(
    step=api_step,
    type="intermediate",
    if_conditions=And(
        IsError(),
        TextContains(text="{{error}}", value="network")
    )
)

# Rate limit handling
rate_limit_handler = ResultHandler(
    step=api_step,
    type="intermediate",
    if_conditions=And(
        IsError(),
        TextContains(text="{{error}}", value="rate_limit")
    )
)

# Validation error handling
validation_error_handler = ResultHandler(
    step=processing_step,
    type="intermediate",
    if_conditions=And(
        IsError(),
        TextContains(text="{{error}}", value="validation")
    )
)
```

## Step Visibility and Output

### Controlling Visibility

Manage what users see during execution:

```python
# Hidden internal step
internal_step = Step(
    agent=agent,
    key="internal_processing",
    actiontype=codeexec.execute(code="internal_calculation()"),
    user_output_visibility="hidden",
    bot_output_visibility="hidden"
)

# Visible analysis step
visible_step = Step(
    agent=agent,
    key="user_analysis",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="{{user_query}}"
    ),
    user_output_visibility="visible",
    bot_output_visibility="visible"
)

# Visible to system, hidden from user
system_step = Step(
    agent=agent,
    key="system_check",
    actiontype=utils.send_status(
        status="checking",
        message="Validating data quality..."
    ),
    user_output_visibility="hidden",
    bot_output_visibility="visible"
)
```

### Custom Messages

Provide informative status messages:

```python
informative_step = Step(
    agent=agent,
    key="analysis",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="{{analysis_query}}"
    ),
    running_message="üîç Analyzing {{data_type}} data...",
    finished_message="‚úÖ Analysis complete! Found {{insights_count}} key insights."
)
```

## Advanced Step Patterns

### Checkpoint and Recovery

Implement checkpointing for long-running processes:

```python
# Checkpoint step
checkpoint_step = Step(
    agent=agent,
    key="checkpoint",
    actiontype=utils.checkpoint_attempt(
        loops="{{current_loop}}",
        attempts="{{attempt_count}}"
    )
)

# Recovery step that uses checkpoint
recovery_step = Step(
    agent=agent,
    key="recovery",
    actiontype=codeexec.execute(
        code="""
# Resume from last checkpoint
checkpoint_data = load_checkpoint("{{checkpoint_id}}")
resume_processing_from(checkpoint_data)
"""
    )
)
```

### Dynamic Step Generation

Create steps dynamically based on runtime conditions:

```python
# Planning step that determines what steps to run
planning_step = Step(
    agent=agent,
    key="plan",
    actiontype=llm.message(
        model="claude-sonnet-4",
        query="Create processing plan for: {{requirements}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "schema": {
                    "type": "object",
                    "properties": {
                        "required_steps": {
                            "type": "array",
                            "items": {"type": "string"}
                        }
                    }
                }
            }
        }
    )
)

# Dynamic execution based on plan
dynamic_step = Step(
    agent=agent,
    key="dynamic_execution",
    actiontype=codeexec.execute(
        code="""
# Execute steps based on plan
required_steps = {{steps.plan.required_steps}}
for step_name in required_steps:
    execute_dynamic_step(step_name)
"""
    ),
    depends_on=[planning_step]
)
```

## Best Practices

<AccordionGroup>
  <Accordion title="Step Design">
    **Single Purpose**: Each step should have one clear responsibility

    **Descriptive Names**: Use clear, descriptive key names for steps

    **Proper Dependencies**: Define dependencies accurately to ensure correct execution order

    **Error Handling**: Plan for failure scenarios in every step

  </Accordion>

  <Accordion title="Data Flow">
    **Clear Inputs**: Make input requirements explicit and well-documented

    **Structured Outputs**: Use consistent output formats, preferably JSON schemas

    **Variable Naming**: Use clear, consistent variable names in templates

    **Data Validation**: Validate data at step boundaries

  </Accordion>

  <Accordion title="Performance">
    **Parallel Execution**: Use parallel execution where steps are independent

    **Conditional Logic**: Use execution modes to avoid unnecessary processing

    **Resource Management**: Set appropriate timeouts and resource limits

    **Caching**: Cache expensive operations within steps

  </Accordion>
</AccordionGroup>

<CardGroup cols={2}>
  <Card title="Actions Reference" icon="bolt" href="/sdk/actions">
    Explore all available action types for steps
  </Card>
  <Card title="Conditions & Logic" icon="code-branch" href="/sdk/conditions">
    Learn about conditional execution and logic
  </Card>
  <Card
    title="Error Handling"
    icon="exclamation-triangle"
    href="/sdk/error-handling"
  >
    Master error handling and recovery patterns
  </Card>
  <Card title="Step Examples" icon="code" href="/examples">
    See real-world step implementations
  </Card>
</CardGroup>
