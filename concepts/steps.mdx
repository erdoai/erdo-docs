---
title: "Steps"
description: "Understanding steps - the building blocks of agent workflows"
---

# Steps

Steps are the individual building blocks that make up agent workflows. Each step represents a single action or operation that contributes to the overall goal of the agent.

## What is a Step?

A step defines:

- **What action to perform** (LLM call, code execution, memory operation, etc.)
- **When to execute** (dependencies, conditions)
- **How to handle results** (success, error, retry logic)
- **What data to use** (inputs, parameters, previous step outputs)

<CardGroup cols={2}>
  <Card title="Action Steps" icon="play">
    Perform specific actions like LLM calls or code execution
  </Card>
  <Card title="Control Steps" icon="route">
    Manage workflow flow and conditional logic
  </Card>
  <Card title="Data Steps" icon="database">
    Handle data transformation and storage operations
  </Card>
  <Card title="Integration Steps" icon="plug">
    Interface with external tools and services
  </Card>
</CardGroup>

## Creating Steps

### Basic Step Creation

```python
from erdo import Agent
from erdo.actions import llm

my_agent = Agent(name="data_analyzer")

basic_step = my_agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="{{user_input}}"
    )
)
```

### Step Parameters

<Tabs>
  <Tab title="Core Parameters">
    ```python
    step = my_agent.step(
        llm.message(
            model="claude-sonnet-4",
            query="{{user_input}}"
        ),
        depends_on=[previous_step],        # Dependencies
        user_output_visibility="visible",  # visible, hidden
        bot_output_visibility="visible",   # visible, hidden
        running_message="Processing...",   # Status during execution
        finished_message="Complete!"      # Status when done
    )
    ```
  </Tab>
  <Tab title="Advanced Parameters">
    ```python
    from erdo.actions import codeexec

    advanced_step = my_agent.step(
        codeexec.execute(
            code_files=[{
                "filename": "process.py",
                "content": "process_data({{input_data}})"
            }]
        ),
        depends_on=[step1, step2],
        timeout=300,                       # Step timeout in seconds
        running_message="Processing advanced data...",
        finished_message="Advanced processing complete!"
    )
    ```

  </Tab>
</Tabs>

## Step Dependencies

### Sequential Execution

Steps can depend on previous steps for ordered execution:

```python
from erdo.actions import websearch, llm

collect_step = agent.step(
    websearch.search(query="{{topic}}")
)

analyze_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Analyze this data: {{collect_step.output.results}}"
    ),
    depends_on=collect_step
)

report_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Create report from: {{analyze_step.output.insights}}"
    ),
    depends_on=analyze_step
)
```

### Parallel Execution

Steps without dependencies can run in parallel:

```python
from erdo.actions import codeexec

process_sales = agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "sales.py",
            "content": "process_sales_data({{sales_data}})"
        }]
    )
)

process_marketing = agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "marketing.py",
            "content": "process_marketing_data({{marketing_data}})"
        }]
    )
)

process_finance = agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "finance.py",
            "content": "process_finance_data({{finance_data}})"
        }]
    )
)

combine_step = agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "combine.py",
            "content": """
combine_results(
    {{process_sales.output.result}},
    {{process_marketing.output.result}},
    {{process_finance.output.result}}
)
"""
        }]
    ),
    depends_on=[process_sales, process_marketing, process_finance]
)
```

### Complex Dependencies

Handle complex dependency patterns:

```python
validation_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Validate results from multiple sources: {{data_collection_step.output}}, {{external_api_step.output}}, {{database_query_step.output}}"
    ),
    depends_on=[data_collection_step, external_api_step, database_query_step]
)
```

## Output Access

### Referencing Step Results

Access outputs from previous steps using the `step.output.field` pattern:

```python
analysis_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Analyze: {{data_input}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "insights": {"type": "array"},
                    "confidence": {"type": "number"},
                    "recommendations": {"type": "array"}
                }
            }
        }
    )
)

report_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Create report using insights: {{analysis_step.output.insights}} with confidence: {{analysis_step.output.confidence}}"
    ),
    depends_on=analysis_step
)
```

### Dynamic Field Access

```python
# Access nested fields
summary_step = agent.step(
    llm.message(
        query="Summarize: {{analysis_step.output.results.summary}}"
    )
)

# Access array elements
detail_step = agent.step(
    llm.message(
        query="Detail first recommendation: {{analysis_step.output.recommendations.0}}"
    )
)
```

## Result Handlers

### Result Handlers

Use `step.on()` for conditional result handling:

```python
from erdo.conditions import IsSuccess, GreaterThan, IsError, LessThan
from erdo.actions import memory, utils

# Store high-confidence analysis results
analysis_step.on(
    IsSuccess() & GreaterThan("confidence", "0.8"),
    memory.store(memory={
        "content": "{{analysis_step.output.insights}}",
        "type": "analysis_result",
        "tags": ["analysis", "high-confidence"]
    })
)

# Flag low confidence results
analysis_step.on(
    IsSuccess() & LessThan("confidence", "0.8") & GreaterThan("confidence", "0.5"),
    utils.send_status(
        status="low_confidence",
        message="Analysis completed but confidence is low"
    )
)

# Handle analysis failures
analysis_step.on(
    IsError(),
    utils.send_status(
        status="failed",
        message="Analysis failed: {{analysis_step.error.message}}"
    )
)
```

### Direct Handlers

Use `step.on()` for immediate action chaining:

```python
# Single action
analysis_step.on(
    IsSuccess() & GreaterThan("confidence", "0.9"),
    utils.send_status(status="excellent", message="Excellent analysis results")
)

# Multiple actions
analysis_step.on(
    IsSuccess() & GreaterThan("confidence", "0.8"),
    utils.send_status(status="high_confidence", message="High confidence analysis"),
    memory.store(memory={
        "content": "{{analysis_step.output.insights}}",
        "type": "verified_analysis"
    }),
    utils.echo(message="Analysis stored successfully")
)
```

## Step Types and Patterns

### Data Processing Steps

```python
from erdo.actions import codeexec

data_step = agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "data_processor.py",
            "content": """
import pandas as pd
import numpy as np

# Load and process data
data = pd.read_csv('{{input_file}}')
processed = data.groupby('category').agg({
    'amount': ['sum', 'mean', 'count'],
    'date': ['min', 'max']
})

result = {
    'summary': processed.to_dict(),
    'total_records': len(data),
    'categories': data['category'].nunique()
}

import json
print(json.dumps(result))
"""
        }]
    )
)
```

### Analysis Steps

```python
insight_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        system_prompt="You are a data analyst expert. Provide actionable insights.",
        query="Analyze this processed data: {{data_step.output.summary}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "properties": {
                    "key_insights": {"type": "array"},
                    "trends": {"type": "array"},
                    "recommendations": {"type": "array"},
                    "risk_factors": {"type": "array"}
                }
            }
        }
    ),
    depends_on=data_step
)
```

### Integration Steps

```python
from erdo.actions import websearch, webparser

research_step = agent.step(
    websearch.search(
        query="{{topic}} industry trends {{current_year}}",
        language="en",
        country="us"
    )
)

parse_step = agent.step(
    webparser.parse(
        url="{{research_step.output.results.0.url}}",
        selectors=["h1", "h2", "p", ".content"],
        extract_links=True
    ),
    depends_on=research_step
)
```

### Memory Operations

```python
from erdo.actions import memory

search_context = agent.step(
    memory.search(
        query="{{user_query}} {{context_keywords}}",
        limit=10,
        organization_scope="specific"
    )
)

store_results = agent.step(
    memory.store(memory=
        memory={
            "content": "{{analysis_step.output.insights}}",
            "description": "Analysis results for {{user_query}}",
            "type": "analysis_result",
            "tags": ["analysis", "{{topic}}", "{{date}}"],
            "searchable_texts": [
                "{{analysis_step.output.insights}}",
                "{{analysis_step.output.recommendations}}"
            ]
        }
    ),
    depends_on=analysis_step
)
```

## Error Handling and Recovery

### Retry Logic

```python
from erdo.conditions import IsError, LessThan

process_step = agent.step(
    codeexec.execute(
        code_files=[{
            "filename": "main_process.py",
            "content": "main_processing_logic({{input_data}})"
        }]
    )
)

# Retry processing with fallback method
process_step.on(
    IsError() & LessThan("retry_count", "3"),
    codeexec.execute(
        code_files=[{
            "filename": "fallback_process.py",
            "content": "fallback_processing_logic({{input_data}})"
        }]
    )
)

# Escalate after max retries
process_step.on(
    IsError() & GreaterThan("retry_count", "2"),
    utils.send_status(
        status="escalated",
        message="Processing failed after 3 attempts: {{process_step.error.message}}",
        priority="high"
    )
)
```

### Graceful Degradation

```python
primary_step = agent.step(
    llm.message(model="claude-sonnet-4", query="{{complex_query}}")
)

# Use simpler model as fallback
primary_step.on(
    IsError(),
    llm.message(
        model="gpt-4",
        query="{{simplified_query}}",
        system_prompt="Provide a basic analysis of the given data"
    )
)
```

## Performance Optimization

### Parallel Processing

```python
# Independent parallel steps
api_call_1 = agent.step(utils.api_call(endpoint="/data/sales"))
api_call_2 = agent.step(utils.api_call(endpoint="/data/marketing"))
api_call_3 = agent.step(utils.api_call(endpoint="/data/finance"))

# Combine after parallel execution
combined_analysis = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Analyze combined data: {{api_call_1.output.data}}, {{api_call_2.output.data}}, {{api_call_3.output.data}}"
    ),
    depends_on=[api_call_1, api_call_2, api_call_3]
)
```

### Conditional Execution

```python
from erdo.conditions import TextContains

initial_check = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="Quick assessment: {{input_data}}"
    )
)

# Run detailed analysis only for complex cases
initial_check.on(
    IsSuccess() & TextContains("assessment", "complex"),
    codeexec.execute(
        code_files=[{
            "filename": "detailed_analysis.py",
            "content": "perform_complex_analysis({{input_data}})"
        }]
    )
)

# Use basic analysis for simple cases
initial_check.on(
    IsSuccess() & TextContains("assessment", "simple"),
    llm.message(
        model="gpt-4",
        query="Basic analysis: {{input_data}}"
    )
)
```

## Best Practices

### Step Design

1. **Single Responsibility**: Each step should have one clear purpose
2. **Descriptive Actions**: Use clear, descriptive action configurations
3. **Proper Dependencies**: Define dependencies to ensure correct execution order
4. **Error Handling**: Always include error handling for robust workflows

### Output Management

```python
# Use structured outputs for better data handling
structured_step = agent.step(
    llm.message(
        model="claude-sonnet-4",
        query="{{analysis_query}}",
        response_format={
            "Type": "json_schema",
            "Schema": {
                "type": "object",
                "required": ["summary", "confidence"],
                "properties": {
                    "summary": {"type": "string"},
                    "confidence": {"type": "number", "minimum": 0, "maximum": 1},
                    "details": {"type": "array"}
                }
            }
        }
    )
)
```

### Memory Usage

```python
# Store important results for future reference
analysis_step.on(
    IsSuccess() & GreaterThan("confidence", "0.8"),
    memory.store(memory={
        "content": "{{analysis_step.output.analysis}}",
        "type": "verified_analysis",
        "tags": ["high-quality", "{{domain}}", "{{timestamp}}"],
        "extra": {
            "confidence": "{{analysis_step.output.confidence}}",
            "model_used": "claude-sonnet-4"
        }
    })
)
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Actions" icon="bolt" href="/concepts/actions">
    Explore the available action types and configurations
  </Card>
  <Card title="Result Handlers" icon="wrench" href="/concepts/result-handlers">
    Master conditional logic and error handling
  </Card>
  <Card title="Examples" icon="lightbulb" href="/examples/data-analysis">
    See complete step implementations in action
  </Card>
  <Card title="SDK Reference" icon="code" href="/sdk/overview">
    Dive deeper into the Python SDK capabilities
  </Card>
</CardGroup>
