---
title: "Why Erdo"
description: "How Erdo's architecture enables comprehensive testing, efficient execution, and reliable agent workflows"
---

# Why Erdo

Erdo's architecture addresses fundamental challenges in agent development through a hybrid Python and Go design that enables comprehensive testing, efficient execution, and reliable deployments.

## The Testing Challenge

Testing agent systems presents several fundamental challenges:

- **Manual Path Coverage**: Complex conditional logic creates many execution paths that must be manually identified and tested
- **State Validation**: Verifying that data flows correctly through templates requires careful manual checking
- **Mock Maintenance**: Creating and maintaining mock responses for all scenarios is time-consuming
- **Integration Cost**: Running full integration tests with LLMs incurs API costs on every execution

## Erdo's Approach

### Hybrid Architecture

Erdo combines Python's expressiveness with Go's performance:

```
┌─────────────────────────────────────┐
│     Python SDK (Agent Definitions)   │
├─────────────────────────────────────┤
│   Template System (Data Flow)       │
├─────────────────────────────────────┤
│   Go Runtime (Execution Engine)      │
└─────────────────────────────────────┘
```

This architecture enables capabilities not possible with pure Python frameworks.

## Key Capabilities

### 1. Automatic Path Enumeration

Erdo's declarative template system allows the CLI to automatically identify and test all possible execution paths through your agent:

```bash
erdo test my_agent.py
```

**What this validates:**
- All conditional branches (success/error handlers, different conditions)
- Template expressions against actual data structures
- Step dependencies and execution ordering
- State availability at each step

Because the agent structure is declarative, the CLI can perform this analysis statically without executing any LLM calls. This is difficult with imperative frameworks where execution paths depend on runtime code execution.

### 2. Efficient Integration Testing

For integration tests that require actual LLM execution, Erdo provides intelligent caching:

```python
from erdo import invoke

def agent_test_analysis():
    response = invoke(
        "data-analyst",
        messages=[{"role": "user", "content": "Analyze Q4 sales"}],
        mode="replay"
    )
    assert response.success
```

**Replay mode behavior:**
- First execution: Calls LLM and caches response
- Subsequent executions: Returns cached response without additional API calls
- Automatic cache invalidation when agent definition changes

This reduces integration test costs and execution time, particularly valuable in CI/CD pipelines.

### 3. Parallel Test Execution

The test runner executes tests concurrently:

```bash
erdo agent-test tests/test_my_agent.py
```

With parallel execution and caching, test suites that would take minutes run in seconds.

## Architecture Benefits

### Template-Based Data Flow

Erdo's template system provides several advantages:

**Static Analysis**
```python
# Template references can be validated before execution
analysis_step = agent.step(
    llm.message(
        model="claude-sonnet-4-5",
        query=state.query,  # CLI validates this field exists
        context=state.previous_results
    )
)
```

**Automatic Path Enumeration**
The CLI can automatically:
- Traverse all conditional branches in your agent
- Generate appropriate test data for each path
- Validate state field availability at each step
- Identify unreachable code

**Template Validation**
Before execution, the CLI validates:
- Referenced state fields exist in context
- Step outputs match expected schemas  
- Parameter definitions are satisfied
- Data types are compatible

This catches errors that would otherwise only appear at runtime.

### Go Runtime Performance

The Go execution engine provides:
- **High Throughput**: Efficient handling of concurrent agent executions
- **Low Latency**: Fast template evaluation and state management
- **Resource Efficiency**: Lower memory footprint than pure Python alternatives
- **Production Reliability**: Static typing and compiled execution

## Comparison: Testing Approaches

<Tabs>
  <Tab title="Imperative Frameworks">
    ```python
    # Manual mocking for unit tests
    def test_agent():
        with mock.patch('llm.call') as mock_llm:
            mock_llm.return_value = "mocked response"
            result = agent.run("analyze data")
            assert "analysis" in result
    
    # Challenges:
    # - Must manually identify all execution paths
    # - Template/state errors only caught at runtime
    # - Mocks must be maintained as agent changes
    # - Integration tests incur API costs per run
    ```
  </Tab>
  <Tab title="Erdo Unit Tests">
    ```bash
    # Automatic path enumeration and validation
    erdo test my_agent.py
    
    # Output:
    # ✅ All 47 execution paths tested successfully
    # ✅ All templates validated
    # ⏱️  Duration: 2.3s
    
    # Benefits:
    # - No manual path identification needed
    # - Template errors caught before execution
    # - No API calls required
    ```
  </Tab>
  <Tab title="Erdo Integration Tests">
    ```python
    def agent_test_analysis():
        response = invoke(
            "data-analyst",
            messages=[{"role": "user", "content": "analyze"}],
            mode="replay"
        )
        assert response.success
    
    # First run: Makes API calls, caches responses
    # Subsequent runs: Uses cached responses
    # Benefit: Reduced API costs in CI/CD
    ```
  </Tab>
</Tabs>

## Development Workflow

### Local Development
```bash
# Validate agent logic without API calls
erdo test my_agent.py --watch

# Test with custom scenarios
erdo test my_agent.py --data scenarios.json
```

### Continuous Integration
```bash
# Run comprehensive test suite
erdo agent-test tests/ --verbose

# Cached responses enable fast CI/CD
# Parallel execution reduces pipeline duration
```

### Production Deployment
```bash
# Sync validated agent to platform
erdo sync my_agent.py

# Confidence from comprehensive test coverage
# Early error detection prevents production issues
```

## Technical Advantages

### For Development Teams

- **Faster Iteration**: Immediate feedback from unit tests
- **Better Coverage**: Automatic testing of all execution paths
- **Early Detection**: Template validation catches errors before deployment
- **Cost Efficiency**: Minimal API costs during development

### For Production Systems

- **Performance**: Go runtime handles high-throughput workloads
- **Reliability**: Comprehensive test coverage reduces production issues
- **Observability**: Declarative templates make data flow traceable
- **Scalability**: Efficient resource utilization supports growth

## Getting Started

<CardGroup cols={2}>
  <Card title="Quick Start" icon="rocket" href="/quickstart">
    Build and test your first agent
  </Card>
  <Card title="Testing Guide" icon="flask" href="/testing/overview">
    Learn about unit and integration testing
  </Card>
  <Card title="Architecture" icon="diagram-project" href="/concepts/overview">
    Understand the technical design
  </Card>
  <Card title="Examples" icon="code" href="/examples/business-automation">
    See real-world implementations
  </Card>
</CardGroup>

